<!DOCTYPE html>

<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Beautiful Soup 4.12.0 文档 &#8212; beautifulsoup 4.4.0q 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=47011fe9"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-bs4">
<span id="beautiful-soup-4-12-0"></span><h1>Beautiful Soup 4.12.0 文档<a class="headerlink" href="#module-bs4" title="此标题的永久链接">¶</a></h1>
<p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> 是一个
可以从 HTML 或 XML 文件中提取数据的 Python 库。它能用你喜欢的解析器和习惯的方式实现
文档树的导航、查找、和修改。它会帮你节省数小时甚至数天的工作时间。</p>
<p>这篇文档介绍了 Beautiful Soup 4 中所有主要特性，并附带例子。文档会展示这个库的适合场景，
工作原理，怎样使用，如何达到预期效果，以及如何处理异常情况。</p>
<p>文档覆盖了 Beautful Soup 4.12.0 版本，文档中的例子使用 Python 3.8 版本编写。</p>
<p>你可能在寻找 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup3</a>
的文档，Beautiful Soup 3 目前已经停止开发，并且自 2020年12月31日以后就停止维护了。
如果想要了解 Beautiful Soup 3 和 Beautiful Soup 4 的不同，参考 <a class="reference internal" href="#id138">迁移到 BS4</a>。</p>
<p>这篇文档已经被翻译成多种语言:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">这篇文档当然还有中文版</a> ,
(<a class="reference external" href="https://github.com/DeronW/beautifulsoup">Github 地址</a>).</p></li>
<li><p>このページは日本語で利用できます(<a class="reference external" href="http://kondou.com/BS4/">外部リンク</a>)</p></li>
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/">이 문서는 한국어 번역도 가능합니다.</a></p></li>
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr">Este documento também está disponível em Português do Brasil.</a></p></li>
<li><p><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ru/">Эта документация доступна на русском языке.</a></p></li>
</ul>
<section id="id5">
<h2>寻求帮助<a class="headerlink" href="#id5" title="此标题的永久链接">¶</a></h2>
<p>如果有关于 Beautiful Soup 4 的疑问，或遇到了问题，可以发送邮件到 <a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup">讨论组</a>。</p>
<p>如果问题中包含要解析的 HTML 代码，那么请在你的问题描述中附带这段HTML文档的 <a class="reference internal" href="#id126">代码诊断</a> <a class="footnote-reference brackets" href="#id148" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>。</p>
<p>如果报告文档中的错误，请指出具体文档的语言版本。</p>
</section>
</section>
<section id="id8">
<h1>快速开始<a class="headerlink" href="#id8" title="此标题的永久链接">¶</a></h1>
<p>下面的一段HTML代码将作为例子被多次用到。这是 <cite>爱丽丝梦游仙境</cite> 的一段内容(以后简称 <em>爱丽丝</em> 的文档):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>上面的 <em>爱丽丝</em> 文档经过 Beautiful Soup 的解析后，会得到一个 <a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a> 的对象，
一个嵌套结构的对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;title&gt;</span>
<span class="c1">#    The Dormouse&#39;s story</span>
<span class="c1">#   &lt;/title&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p class=&quot;title&quot;&gt;</span>
<span class="c1">#    &lt;b&gt;</span>
<span class="c1">#     The Dormouse&#39;s story</span>
<span class="c1">#    &lt;/b&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c1">#    Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c1">#     Elsie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    ,</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#     Lacie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    and</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#     Tillie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    ; and they lived at the bottom of a well.</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c1">#    ...</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>这是几个简单的浏览结构化数据的方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;head&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c1"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
<p>常见任务之一，就是从文档中找到所有 &lt;a&gt; 标签的链接:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;href&#39;</span><span class="p">))</span>
    <span class="c1"># http://example.com/elsie</span>
    <span class="c1"># http://example.com/lacie</span>
    <span class="c1"># http://example.com/tillie</span>
</pre></div>
</div>
<p>另一种常见任务，是从文档中获取所有文字内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>
<span class="c1"># The Dormouse&#39;s story</span>
<span class="c1">#</span>
<span class="c1"># The Dormouse&#39;s story</span>
<span class="c1">#</span>
<span class="c1"># Once upon a time there were three little sisters; and their names were</span>
<span class="c1"># Elsie,</span>
<span class="c1"># Lacie and</span>
<span class="c1"># Tillie;</span>
<span class="c1"># and they lived at the bottom of a well.</span>
<span class="c1">#</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>这是你想要的吗？是的话，继续看下去。</p>
</section>
<section id="id9">
<h1>安装 Beautiful Soup<a class="headerlink" href="#id9" title="此标题的永久链接">¶</a></h1>
<p>如果你用的是新版的 Debain 或 Ubuntu，那么可以通过系统的软件包管理来安装:</p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">apt</kbd>-<kbd class="kbd docutils literal notranslate">get</kbd> <kbd class="kbd docutils literal notranslate">install</kbd> <kbd class="kbd docutils literal notranslate">python3</kbd>-<kbd class="kbd docutils literal notranslate">bs4</kbd></kbd></p>
<p>Beautiful Soup 4 通过 PyPi 发布，所以如果无法使用系统包管理安装，那么
也可以通过 <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 来安装。包的名字是 <code class="docutils literal notranslate"><span class="pre">beautifulsoup4</span></code>。
确保使用的是与 Python 版本对应的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 或 <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> 版本
(他们的名字也可能是 <code class="docutils literal notranslate"><span class="pre">pip3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> )。</p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">easy_install</kbd> <kbd class="kbd docutils literal notranslate">beautifulsoup4</kbd></kbd></p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">pip</kbd> <kbd class="kbd docutils literal notranslate">install</kbd> <kbd class="kbd docutils literal notranslate">beautifulsoup4</kbd></kbd></p>
<p>(在 PyPi 中还有一个名字是 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 的包，但那可能不是你想要的，那是
<a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup3</a> 版本。因为很多项目还在使用BS3, 所以 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
包依然有效。但是新项目中，应该安装 <code class="docutils literal notranslate"><span class="pre">beautifulsoup4</span></code>。)</p>
<p>如果没有安装 <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pip</span></code> ，那也可以 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/download/4.x/">下载 BS4 的源码</a> ,
然后通过 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 来安装。</p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">Python</kbd> <kbd class="kbd docutils literal notranslate">setup.py</kbd> <kbd class="kbd docutils literal notranslate">install</kbd></kbd></p>
<p>如果上述安装方法都行不通，根据 Beautiful Soup 的协议，可以将项目的代码打包在
你的项目中，这样无须安装即可使用。</p>
<p>Beautiful Soup 用 Python 3.10 版本开发，但也可以在当前的其它版本中运行。</p>
<section id="id10">
<h2>安装解析器<a class="headerlink" href="#id10" title="此标题的永久链接">¶</a></h2>
<p>Beautiful Soup 支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器，
其中一个是 <a class="reference external" href="http://lxml.de/">lxml parser</a> 。根据安装方法的不同，
可以选择下列方法来安装 lxml:</p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">apt</kbd>-<kbd class="kbd docutils literal notranslate">get</kbd> <kbd class="kbd docutils literal notranslate">install</kbd> <kbd class="kbd docutils literal notranslate">Python</kbd>-<kbd class="kbd docutils literal notranslate">lxml</kbd></kbd></p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">easy_install</kbd> <kbd class="kbd docutils literal notranslate">lxml</kbd></kbd></p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">pip</kbd> <kbd class="kbd docutils literal notranslate">install</kbd> <kbd class="kbd docutils literal notranslate">lxml</kbd></kbd></p>
<p>另一个可供选择的解析器是纯 Python 实现的 <a class="reference external" href="http://code.google.com/p/html5lib/">html5lib</a> ,
html5lib 的解析方式与浏览器相同，根据安装方法的不同，可以选择下列方法来安装html5lib:</p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">apt</kbd>-<kbd class="kbd docutils literal notranslate">get</kbd> <kbd class="kbd docutils literal notranslate">install</kbd> <kbd class="kbd docutils literal notranslate">python</kbd>-<kbd class="kbd docutils literal notranslate">html5lib</kbd></kbd></p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">easy_install</kbd> <kbd class="kbd docutils literal notranslate">html5lib</kbd></kbd></p>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">$</kbd> <kbd class="kbd docutils literal notranslate">pip</kbd> <kbd class="kbd docutils literal notranslate">install</kbd> <kbd class="kbd docutils literal notranslate">html5lib</kbd></kbd></p>
<p>下表描述了几种解析器的优缺点:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>解析器</p></th>
<th class="head"><p>使用方法</p></th>
<th class="head"><p>优势</p></th>
<th class="head"><p>劣势</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line">Python 标准库</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;html.parser&quot;)</span></code></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line">- Python的内置标准库</div>
<div class="line">- 执行速度较快</div>
<div class="line">- 容错能力强</div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 速度没有 lxml 快，容错没有 html5lib强</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">lxml HTML 解析器</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;lxml&quot;)</span></code></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 速度快</div>
<div class="line">- 容错能力强</div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 额外的 C 依赖</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">lxml XML 解析器</div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">[&quot;lxml-xml&quot;])</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;xml&quot;)</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 速度快</div>
<div class="line">- 唯一支持 XML 的解析器</div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 额外的 C 依赖</div>
<div class="line"><br /></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">html5lib</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;html5lib&quot;)</span></code></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 最好的容错性</div>
<div class="line">- 以浏览器的方式解析文档</div>
<div class="line">- 生成 HTML5 格式的文档</div>
</div>
</td>
<td><div class="line-block">
<div class="line">- 速度慢</div>
<div class="line">- 额外的 Python 依赖</div>
<div class="line"><br /></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>如果可以，推荐使用 lxml 来获得更高的速度。</p>
<p>注意，如果一段文档格式不标准，那么在不同解析器生成的 Beautiful Soup 数可能不一样。
查看 <a class="reference internal" href="#id101">解析器之间的区别</a>  了解更多细节。</p>
</section>
</section>
<section id="id11">
<h1>如何使用<a class="headerlink" href="#id11" title="此标题的永久链接">¶</a></h1>
<p>解析文档是，将文档传入 <a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a> 的构造方法。也可以传入一段字符串
或一个文件句柄:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;index.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;html&gt;a web page&lt;/html&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>首先，文档被转换成 Unicode，并且 HTML 中的实体也都被转换成 Unicode 编码</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacr&amp;eacute; bleu!&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>然后，Beautiful Soup 选择最合适的解析器来解析这段文档。如果指定了解析器那么 Beautiful Soup
会选择指定的解析器来解析文档。(参考 <a class="reference internal" href="#id130">解析成XML</a> )。</p>
</section>
<section id="id12">
<h1>对象的种类<a class="headerlink" href="#id12" title="此标题的永久链接">¶</a></h1>
<p>Beautiful Soup 将复杂的 HTML 文档转换成一个复杂的由 Python 对象构成的树形结构，但处理对象
的过程只包含 4 种类型的对象: <code class="xref py py-class docutils literal notranslate"><span class="pre">Tag</span></code>, <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a>,
<a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a>, 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Comment</span></code>。</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tag</span></code>
<code class="docutils literal notranslate"><span class="pre">Tag</span></code> 对象与 XML 或 HTML 原生文档中的 tag 相同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.Tag&#39;&gt;</span>
</pre></div>
</div>
<p>Tag有很多属性和方法，在 <a class="reference internal" href="#id17">遍历文档树</a> 和 <a class="reference internal" href="#id28">搜索文档树</a> 中有详细解释。
现在介绍一下 tag 中最重要的属性: name 和 attributes。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="bs4.name">
<span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#bs4.name" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>每个 tag 都有一个名字:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;b&#39;</span>
</pre></div>
</div>
<p>如果改变了 tag 的 name，那将影响所有通过当前 Beautiful Soup 对象生成的HTML文档:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blockquote&quot;</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote class=&quot;boldest&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="bs4.attrs">
<span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">attrs</span></span><a class="headerlink" href="#bs4.attrs" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>一个 HTML 或 XML 的 tag 可能有很多属性。tag <code class="docutils literal notranslate"><span class="pre">&lt;b</span> <span class="pre">id=&quot;boldest&quot;&gt;</span></code> 有
一个 “id” 的属性，值为 “boldest”。你可以想处理一个字段一样来处理 tag 的属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b id=&quot;boldest&quot;&gt;bold&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">b</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># &#39;boldest&#39;</span>
</pre></div>
</div>
<p>也可以直接”点”取属性，比如: <code class="docutils literal notranslate"><span class="pre">.attrs</span></code> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">attrs</span>
<span class="c1"># {u&#39;class&#39;: u&#39;boldest&#39;}</span>
</pre></div>
</div>
<p>tag 的属性可以被添加、删除或修改。再说一次，tag的属性操作方法与字典一样</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;another-attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c1"># &lt;b another-attribute=&quot;1&quot; id=&quot;verybold&quot;&gt;&lt;/b&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;another-attribute&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;bold&lt;/b&gt;</span>

<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># KeyError: &#39;id&#39;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<section id="multivalue">
<span id="id13"></span><h2>多值属性<a class="headerlink" href="#multivalue" title="此标题的永久链接">¶</a></h2>
<p>HTML 4 定义了一系列可以包含多个值的属性。在 HTML5 中移除了一些，却增加更多。
最常见的多值的属性是 <code class="docutils literal notranslate"><span class="pre">class</span></code> (一个 tag 可以有多个 CSS class)。还有一些
属性 <code class="docutils literal notranslate"><span class="pre">rel</span></code>、 <code class="docutils literal notranslate"><span class="pre">rev</span></code>、 <code class="docutils literal notranslate"><span class="pre">accept-charset</span></code>、 <code class="docutils literal notranslate"><span class="pre">headers</span></code>、 <code class="docutils literal notranslate"><span class="pre">accesskey</span></code>。
默认情况，Beautiful Soup 中将多值属性解析为一个列表:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> css_soup = BeautifulSoup(&#39;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#39;, &#39;html.parser&#39;)
 css_soup.p[&#39;class&#39;]
 # [&#39;body&#39;]

 css_soup = BeautifulSoup(&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;, &#39;html.parser&#39;)
 css_soup.p[&#39;class&#39;]
 # [&#39;body&#39;, &#39;strikeout&#39;]

If an attribute `looks` like it has more than one value, but it&#39;s not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup will leave the attribute alone::

 id_soup = BeautifulSoup(&#39;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#39;, &#39;html.parser&#39;)
 id_soup.p[&#39;id&#39;]
 # &#39;my id&#39;
</pre></div>
</div>
<p>如果某个属性看起来好像有多个值，但在任何版本的 HTML 定义中都没有将其定义为多值属性，
那么 Beautiful Soup 会将这个属性作为单值返回</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">id_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># &#39;my id&#39;</span>
</pre></div>
</div>
<p>将 tag 转换成字符串时，多值属性会合并为一个值</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rel_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;Back to the &lt;a rel=&quot;index first&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span>
<span class="c1"># [&#39;index&#39;, &#39;first&#39;]</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;contents&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rel_soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>若想强制将所有属性当做多值进行解析，可以在 <a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a> 构造方法中设置
<code class="docutils literal notranslate"><span class="pre">multi_valued_attributes=None</span></code> 参数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">no_list_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">no_list_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># &#39;body strikeout&#39;</span>
</pre></div>
</div>
<p>或者使用 <code class="docutils literal notranslate"><span class="pre">get_attribute_list</span></code> 方法来获取多值列表，不管是不是一个多值属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get_attribute_list</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="c1"># [&quot;my id&quot;]</span>
</pre></div>
</div>
<p>如果以 XML 方式解析文档，则没有多值属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;xml&#39;</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># &#39;body strikeout&#39;</span>
</pre></div>
</div>
<p>但是，可以通过配置 <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes</span></code> 参数来修改:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">class_is_multi</span><span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;*&#39;</span> <span class="p">:</span> <span class="s1">&#39;class&#39;</span><span class="p">}</span>
<span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="n">class_is_multi</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [&#39;body&#39;, &#39;strikeout&#39;]</span>
</pre></div>
</div>
<p>可能实际当中并不需要修改默认配置，默认采用的是 HTML 标准:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.builder</span> <span class="kn">import</span> <span class="n">builder_registry</span>
<span class="n">builder_registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;html&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">DEFAULT_CDATA_LIST_ATTRIBUTES</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.NavigableString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">NavigableString</span></span><a class="headerlink" href="#bs4.NavigableString" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

</section>
<section id="id14">
<h2>可遍历的字符串<a class="headerlink" href="#id14" title="此标题的永久链接">¶</a></h2>
<p>字符串对应 tag 中的一段文本。Beautiful Soup 用 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a>
类来包装 tag 中的字符串:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># &#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.NavigableString&#39;&gt;</span>
</pre></div>
</div>
<p>一个 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 对象与 Python 中的Unicode 字符串相同，
并且还支持包含在 <a class="reference internal" href="#id17">遍历文档树</a> 和 <a class="reference internal" href="#id28">搜索文档树</a> 中的一些特性。通过 <code class="docutils literal notranslate"><span class="pre">str</span></code> 方法可以直接将
<a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 对象转换成 Unicode 字符串:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unicode_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">unicode_string</span>
<span class="c1"># &#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">unicode_string</span><span class="p">)</span>
<span class="c1"># &lt;type &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>tag 中包含的字符串不能直接编辑，但是可以被替换成其它的字符串，用 <a class="reference internal" href="#replace-with"><span class="std std-ref">replace_with()</span></a> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="s2">&quot;No longer bold&quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 对象支持 <a class="reference internal" href="#id17">遍历文档树</a> 和 <a class="reference internal" href="#id28">搜索文档树</a> 中定义的大部分属性，
并非全部。尤其是，一个字符串不能包含其它内容(tag 能够包含字符串或是其它 tag)，字符串不支持
<code class="docutils literal notranslate"><span class="pre">.contents</span></code> 或 <code class="docutils literal notranslate"><span class="pre">.string</span></code> 属性或 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法。</p>
<p>如果想在 Beautiful Soup 之外使用 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 对象，需要调用 <code class="docutils literal notranslate"><span class="pre">unicode()</span></code>
方法，将该对象转换成普通的Unicode字符串，否则就算 Beautiful Soup 方法已经执行结束，该对象的输出
也会带有对象的引用地址。这样会浪费内存。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.BeautifulSoup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">BeautifulSoup</span></span><a class="headerlink" href="#bs4.BeautifulSoup" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<hr class="docutils" />
<p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象表示的是一个文档的全部内容。大部分时候，可以把它当作 <code class="docutils literal notranslate"><span class="pre">Tag</span></code> 对象，
它支持 <a class="reference internal" href="#id17">遍历文档树</a> 和 <a class="reference internal" href="#id28">搜索文档树</a> 中描述的大部分的方法。</p>
<p>因为 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性。
但有时查看它的 <code class="docutils literal notranslate"><span class="pre">.name</span></code> 属性是很方便的，所以 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象包含了一个
值为 “[document]” 的特殊属性 <code class="docutils literal notranslate"><span class="pre">.name</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;[document]&#39;</span>
</pre></div>
</div>
</section>
<section id="id15">
<h2>注释及特殊字符串<a class="headerlink" href="#id15" title="此标题的永久链接">¶</a></h2>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tag</span></code>, <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a>, <a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a>
几乎覆盖了html和xml中的所有内容，但是还有一些特殊对象。容易让人担心的内容是文档的注释部分:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="nb">type</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.Comment&#39;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Comment</span></code> 对象是一个特殊类型的 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">comment</span>
<span class="c1"># u&#39;Hey, buddy. Want to buy a used parser&#39;</span>
</pre></div>
</div>
<p>但是当它出现在 HTML 文档中时，<code class="xref py py-class docutils literal notranslate"><span class="pre">Comment</span></code> 对象会使用特殊的格式输出:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;b&gt;</span>
<span class="c1">#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;</span>
<span class="c1"># &lt;/b&gt;</span>
</pre></div>
</div>
<section id="html">
<h3>针对 HTML 文档<a class="headerlink" href="#html" title="此标题的永久链接">¶</a></h3>
<p>Beautiful Soup 定义了一些 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类来处理特定的 HTML 标签。
通过忽略页面中表示程序指令的字符串，可以更容易挑出页面的 body 内容。
（这些类是在 Beautiful Soup 4.9.0 版本中添加的，html5lib 解析器不会使用它们）</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.Stylesheet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">Stylesheet</span></span><a class="headerlink" href="#bs4.Stylesheet" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示嵌入的 CSS 脚本；
内容是 <code class="docutils literal notranslate"><span class="pre">&lt;style&gt;</span></code> 标签内部的所有字符串。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.Script">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">Script</span></span><a class="headerlink" href="#bs4.Script" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示嵌入的 JavaScript 脚本；
内容是 <code class="docutils literal notranslate"><span class="pre">&lt;script&gt;</span></code> 标签内部的所有字符串。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.Template">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">Template</span></span><a class="headerlink" href="#bs4.Template" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示嵌入的 HTML 模板，
内容是 <code class="docutils literal notranslate"><span class="pre">&lt;template&gt;</span></code>  标签内部的所有字符串。</p>
</section>
<section id="xml">
<h3>针对 XML 文档<a class="headerlink" href="#xml" title="此标题的永久链接">¶</a></h3>
<p>Beautiful Soup 定义了一些 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类来处理 XML 文档中的特定
字符串。比如 <code class="xref py py-class docutils literal notranslate"><span class="pre">Comment</span></code>，这些 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 的子类生成字符
串时会添加额外内容。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.Declaration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">Declaration</span></span><a class="headerlink" href="#bs4.Declaration" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示 XML 文档开头的
<a class="reference external" href="https://www.w3.org/TR/REC-xml/#sec-prolog-dtd">declaration</a> 。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.Doctype">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">Doctype</span></span><a class="headerlink" href="#bs4.Doctype" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示可能出现在 XML 文档开头的
<a class="reference external" href="https://www.w3.org/TR/REC-xml/#dt-doctype">document type
declaration</a> 。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.CData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">CData</span></span><a class="headerlink" href="#bs4.CData" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示
<a class="reference external" href="https://www.w3.org/TR/REC-xml/#sec-cdata-sect">CData section</a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.ProcessingInstruction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">ProcessingInstruction</span></span><a class="headerlink" href="#bs4.ProcessingInstruction" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>有一种 <a class="reference internal" href="#bs4.NavigableString" title="bs4.NavigableString"><code class="xref py py-class docutils literal notranslate"><span class="pre">NavigableString</span></code></a> 子类表示 <a class="reference external" href="https://www.w3.org/TR/REC-xml/#sec-pi">XML 处理指令</a>。</p>
</section>
</section>
</section>
<section id="id17">
<h1>遍历文档树<a class="headerlink" href="#id17" title="此标题的永久链接">¶</a></h1>
<p>还是用”爱丽丝”的文档来做例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">    &lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>通过这段例子来演示怎样从文档的一段内容找到另一段内容</p>
<section id="id18">
<h2>子节点<a class="headerlink" href="#id18" title="此标题的永久链接">¶</a></h2>
<p>tag 可能包含多个字符串或其它的 tag，这些都是这个 Tag 的子节点。Beautiful Soup 提供了许多查找
和操作子节点的方法。</p>
<p>注意: Beautiful Soup中字符串节点不支持这些属性，因为字符串没有子节点。</p>
<section id="tag">
<h3>Tag 的名字<a class="headerlink" href="#tag" title="此标题的永久链接">¶</a></h3>
<p>操作文档树最简单的方法就是告诉它你想获取的 tag 的 name。如果想获取 &lt;head&gt; 标签，只要用 <code class="docutils literal notranslate"><span class="pre">soup.head</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>这是个获取tag的小窍门，可以在文档树的tag中多次调用这个方法。下面的代码可以获取 &lt;body&gt; 标签中的
第一个 &lt;b&gt; 标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;</span>
</pre></div>
</div>
<p>通过点取属性的方式只能获得当前名字的第一个tag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>如果想要得到所有的 &lt;a&gt; 标签，或是比通过名字获取内容更复杂的方法时，就需要用到 <a class="reference internal" href="#id28">搜索文档树</a>
中描述的方法，比如: <cite>find_all()</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</section>
<section id="contents-children">
<h3><code class="docutils literal notranslate"><span class="pre">.contents</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.children</span></code><a class="headerlink" href="#contents-children" title="此标题的永久链接">¶</a></h3>
<p>Tag 的 <code class="docutils literal notranslate"><span class="pre">.contents</span></code> 属性可以将 tag 的全部子节点以列表的方式输出:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">head_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="n">head_tag</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/title&gt;]</span>

<span class="n">title_tag</span> <span class="o">=</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">title_tag</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;The Dormouse&#39;s story&#39;]</span>
</pre></div>
</div>
<p><a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a> 对象一定会包含子节点。下面例子中 &lt;html&gt; 标签就是 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
对象的子节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
<span class="c1"># 1</span>
<span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;html&#39;</span>
</pre></div>
</div>
<p>字符串没有 <code class="docutils literal notranslate"><span class="pre">.contents</span></code> 属性，因为字符串没有子节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">text</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># AttributeError: &#39;NavigableString&#39; object has no attribute &#39;contents&#39;</span>
</pre></div>
</div>
<p>通过 tag 的 <code class="docutils literal notranslate"><span class="pre">.children</span></code> 生成器，可以对 tag 的子节点进行循环:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="c1"># The Dormouse&#39;s story</span>
</pre></div>
</div>
<p>如果想要修改 tag 的子节点，使用 <a class="reference internal" href="#id90">修改文档树</a> 中描述的方法。不要直接修改 <code class="docutils literal notranslate"><span class="pre">contents</span></code> 列表:
那样会导致细微且难以定位的问题。</p>
</section>
<section id="descendants">
<h3><code class="docutils literal notranslate"><span class="pre">.descendants</span></code><a class="headerlink" href="#descendants" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">.contents</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.children</span></code> 属性仅包含 tag 的直接子节点。例如，&lt;head&gt; 标签只有一个直接
子节点 &lt;title&gt;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>但是 &lt;title&gt; 标签也包含一个子节点：字符串 “The Dormouse’s story”。这种情况下字符串
“The Dormouse’s story” 也属于 &lt;head&gt; 标签的子节点。 <code class="docutils literal notranslate"><span class="pre">.descendants</span></code> 属性可以对
所有 tag 的子孙节点进行递归循环 <a class="footnote-reference brackets" href="#id152" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> ，包括子节点，子节点的子节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
    <span class="c1"># The Dormouse&#39;s story</span>
</pre></div>
</div>
<p>上面的例子中，&lt;head&gt; 标签只有一个子节点，但是有 2 个子孙节点: &lt;head&gt; 标签和 &lt;head&gt; 的子节点。
<a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a> 对象只有一个直接子节点(&lt;html&gt; 节点)，却有很多子孙节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
<span class="c1"># 1</span>
<span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">descendants</span><span class="p">))</span>
<span class="c1"># 25</span>
</pre></div>
</div>
</section>
<section id="string">
<span id="id20"></span><h3><code class="docutils literal notranslate"><span class="pre">.string</span></code><a class="headerlink" href="#string" title="此标题的永久链接">¶</a></h3>
<p>如果 tag 只有一个 <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> 类型子节点，那么这个tag可以使用 <code class="docutils literal notranslate"><span class="pre">.string</span></code>
得到子节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>如果一个tag仅有一个子节点，那么这个tag也可以使用 <code class="docutils literal notranslate"><span class="pre">.string</span></code> 方法，输出结果与当前唯一
子节点的 <code class="docutils literal notranslate"><span class="pre">.string</span></code> 结果相同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>如果tag包含了多个子节点，tag就无法确定 <code class="docutils literal notranslate"><span class="pre">.string</span></code> 方法应该调用哪个子节点的内容，
<code class="docutils literal notranslate"><span class="pre">.string</span></code> 的输出结果是 <code class="docutils literal notranslate"><span class="pre">None</span></code> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
</section>
<section id="strings-stripped-strings">
<span id="string-generators"></span><h3>.strings 和 stripped_strings<a class="headerlink" href="#strings-stripped-strings" title="此标题的永久链接">¶</a></h3>
<p>如果 tag 中包含多个字符串 <a class="footnote-reference brackets" href="#id149" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> ,可以使用 <code class="docutils literal notranslate"><span class="pre">.strings</span></code> 来循环获取:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c1"># u&#39;\n\n&#39;</span>
    <span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c1"># u&#39;\n\n&#39;</span>
    <span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
    <span class="c1"># u&#39;Elsie&#39;</span>
    <span class="c1"># u&#39;,\n&#39;</span>
    <span class="c1"># u&#39;Lacie&#39;</span>
    <span class="c1"># u&#39; and\n&#39;</span>
    <span class="c1"># u&#39;Tillie&#39;</span>
    <span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c1"># u&#39;\n\n&#39;</span>
    <span class="c1"># u&#39;...&#39;</span>
    <span class="c1"># u&#39;\n&#39;</span>
</pre></div>
</div>
<p>输出的字符串中可能包含了很多空格或空行，使用 <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code> 可以去除多余空白内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
    <span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were&#39;</span>
    <span class="c1"># u&#39;Elsie&#39;</span>
    <span class="c1"># u&#39;,&#39;</span>
    <span class="c1"># u&#39;Lacie&#39;</span>
    <span class="c1"># u&#39;and&#39;</span>
    <span class="c1"># u&#39;Tillie&#39;</span>
    <span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c1"># u&#39;...&#39;</span>
</pre></div>
</div>
<p>全部是空格的行会被忽略掉，段首和段末的空白会被删除</p>
</section>
</section>
<section id="id22">
<h2>父节点<a class="headerlink" href="#id22" title="此标题的永久链接">¶</a></h2>
<p>继续分析文档树，每个 tag 或字符串都有父节点: 包含当前内容的 tag</p>
<section id="parent">
<span id="id23"></span><h3>.parent<a class="headerlink" href="#parent" title="此标题的永久链接">¶</a></h3>
<p>通过 <code class="docutils literal notranslate"><span class="pre">.parent</span></code> 属性来获取某个元素的父节点。在例子“爱丽丝”的文档中，&lt;head&gt; 标签是
&lt;title&gt; 标签的父节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">title_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="n">title_tag</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
</pre></div>
</div>
<p>文档的 title 字符串也有父节点: &lt;title&gt; 标签</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>文档的顶层节点比如 &lt;html&gt; 的父节点是 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">html</span>
<span class="nb">type</span><span class="p">(</span><span class="n">html_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.BeautifulSoup&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">.parent</span></code> 是None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
</section>
<section id="parents">
<span id="id24"></span><h3>.parents<a class="headerlink" href="#parents" title="此标题的永久链接">¶</a></h3>
<p>通过元素的 <code class="docutils literal notranslate"><span class="pre">.parents</span></code> 属性可以递归得到元素的所有父辈节点，下面的例子使用了 <code class="docutils literal notranslate"><span class="pre">.parents</span></code>
方法遍历了 &lt;a&gt; 标签到根节点的所有节点。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">link</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># p</span>
<span class="c1"># body</span>
<span class="c1"># html</span>
<span class="c1"># [document]</span>
<span class="c1"># None</span>
</pre></div>
</div>
</section>
</section>
<section id="id25">
<h2>兄弟节点<a class="headerlink" href="#id25" title="此标题的永久链接">¶</a></h2>
<p>看一段简单的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1">#   &lt;a&gt;</span>
<span class="c1">#    &lt;b&gt;</span>
<span class="c1">#     text1</span>
<span class="c1">#    &lt;/b&gt;</span>
<span class="c1">#    &lt;c&gt;</span>
<span class="c1">#     text2</span>
<span class="c1">#    &lt;/c&gt;</span>
<span class="c1">#   &lt;/a&gt;</span>
</pre></div>
</div>
<p>因为 &lt;b&gt; 标签和 &lt;c&gt; 标签是同一层: 他们是同一个元素的子节点，所以 &lt;b&gt; 和 &lt;c&gt; 可以被称为兄弟节点。
一段文档以标准格式输出时，兄弟节点有相同的缩进级别。在代码中也可以使用这种关系。</p>
<section id="next-sibling-previous-sibling">
<h3>.next_sibling 和 .previous_sibling<a class="headerlink" href="#next-sibling-previous-sibling" title="此标题的永久链接">¶</a></h3>
<p>在文档树中，使用 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code> 属性来查询兄弟节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &lt;c&gt;text2&lt;/c&gt;</span>

<span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">previous_sibling</span>
<span class="c1"># &lt;b&gt;text1&lt;/b&gt;</span>
</pre></div>
</div>
<p>&lt;b&gt; 标签有 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 属性，但是没有 <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code> 属性，
因为 &lt;b&gt; 标签在同级节点中是第一个。同理，&lt;c&gt;标签有 <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code> 属性，
却没有 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">previous_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>例子中的字符串 “text1” 和 “text2” 不是兄弟节点，因为它们的父节点不同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;text1&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>实际文档中的 tag 的 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code> 属性通常是字符串或空白。
看看“爱丽丝”文档:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/elsie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link1&quot;</span><span class="o">&gt;</span><span class="n">Elsie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/lacie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="o">&gt;</span><span class="n">Lacie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/tillie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="o">&gt;</span><span class="n">Tillie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>如果以为第一个 &lt;a&gt; 标签的 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 结果是第二个 &lt;a&gt; 标签，那就错了，
真实结果是第一个 &lt;a&gt; 标签和第二个&lt;a&gt; 标签之间的顿号和换行符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># u&#39;,\n&#39;</span>
</pre></div>
</div>
<p>第二个&lt;a&gt;标签是顿号的 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
</pre></div>
</div>
</section>
<section id="next-siblings-previous-siblings">
<span id="sibling-generators"></span><h3>.next_siblings 和 .previous_siblings<a class="headerlink" href="#next-siblings-previous-siblings" title="此标题的永久链接">¶</a></h3>
<p>通过 <code class="docutils literal notranslate"><span class="pre">.next_siblings</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.previous_siblings</span></code> 属性可以对当前节点的兄弟节点迭代输出:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">next_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
<span class="c1"># &#39;,\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
<span class="c1"># &#39; and\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
<span class="c1"># &#39;; and they lived at the bottom of a well.&#39;</span>

<span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">previous_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
<span class="c1"># &#39; and\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
<span class="c1"># &#39;,\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
<span class="c1"># &#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
</pre></div>
</div>
</section>
</section>
<section id="id26">
<h2>回退和前进<a class="headerlink" href="#id26" title="此标题的永久链接">¶</a></h2>
<p>看一下“爱丽丝” 文档:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;&lt;</span><span class="n">head</span><span class="o">&gt;&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;title&quot;</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>HTML解析器把这段字符串转换成一连串的事件: “打开&lt;html&gt;标签”,”打开一个&lt;head&gt;标签”,
“打开一个&lt;title&gt;标签”,”添加一段字符串”,”关闭&lt;title&gt;标签”,”打开&lt;p&gt;标签”,等等。
Beautiful Soup提供了重现解析器初始化过程的方法。</p>
<section id="next-element-previous-element">
<span id="element-generators"></span><h3>.next_element 和 .previous_element<a class="headerlink" href="#next-element-previous-element" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">.next_element</span></code> 属性指向解析过程中下一个被解析的对象(字符串或tag),
结果可能与 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 相同，但通常是不一样的。</p>
<p>这是“爱丽丝”文档中最后一个 &lt;a&gt; 标签，它的 <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> 结果是一个字符串，
因为当前的解析过程 <a class="footnote-reference brackets" href="#id149" id="id27" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> 因为当前的解析过程因为遇到了&lt;a&gt;标签而中断了:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_a_tag</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &#39;; and they lived at the bottom of a well.&#39;</span>
</pre></div>
</div>
<p>但这个 &lt;a&gt; 标签的 <code class="docutils literal notranslate"><span class="pre">.next_element</span></code> 属性结果是在 &lt;a&gt; 标签被解析之后的解析内容，
不是 &lt;a&gt; 标签后的句子部分，而是字符串 “Tillie”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_element</span>
<span class="c1"># u&#39;Tillie&#39;</span>
</pre></div>
</div>
<p>这是因为在原始文档中，字符串 “Tillie” 在分号前出现，解析器先进入 &lt;a&gt; 标签，
然后是字符串 “Tillie”，然后关闭 &lt;/a&gt; 标签，然后是分号和剩余部分。
分号与 &lt;a&gt; 标签在同一层级，但是字符串 “Tillie” 会先被解析。</p>
<p><code class="docutils literal notranslate"><span class="pre">.previous_element</span></code> 属性刚好与 <code class="docutils literal notranslate"><span class="pre">.next_element</span></code> 相反，
它指向当前被解析的对象的前一个解析对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span><span class="o">.</span><span class="n">next_element</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
</section>
<section id="next-elements-previous-elements">
<h3>.next_elements 和 .previous_elements<a class="headerlink" href="#next-elements-previous-elements" title="此标题的永久链接">¶</a></h3>
<p>通过 <code class="docutils literal notranslate"><span class="pre">.next_elements</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.previous_elements</span></code> 的迭代器就可以向前或向后
访问文档的解析内容，就好像文档正在被解析一样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_elements</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="c1"># u&#39;...&#39;</span>
<span class="c1"># u&#39;\n&#39;</span>
<span class="c1"># None</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id28">
<h1>搜索文档树<a class="headerlink" href="#id28" title="此标题的永久链接">¶</a></h1>
<p>Beautiful Soup 定义了很多相似的文档搜索方法，这里着重介绍2个: <code class="docutils literal notranslate"><span class="pre">find()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>，
其它方法的参数和用法类似，所以一笔带过。</p>
<p>再以“爱丽丝”文档作为例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 这种过滤方法，就可以检索想要查找的文档内容。</p>
<section id="id29">
<h2>过滤器类型<a class="headerlink" href="#id29" title="此标题的永久链接">¶</a></h2>
<p>介绍 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 或类似方法前，先介绍一下这些方法可以使用哪些过滤器的类型 <a class="footnote-reference brackets" href="#id150" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>,
这些过滤器在搜索的 API 中反复出现。过滤器可以作用在 tag 的 name 上，节点的属性上，
字符串上或与他们混合使用。</p>
<section id="id31">
<span id="id32"></span><h3>字符串<a class="headerlink" href="#id31" title="此标题的永久链接">¶</a></h3>
<p>最简单的过滤器是字符串。在搜索方法中传入一个字符串参数，Beautiful Soup
会查找与字符串完整匹配的内容，下面的例子用于查找文档中所有的 &lt;b&gt; 标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]</span>
</pre></div>
</div>
<p>如果传入字节码参数，Beautiful Soup会当作UTF-8编码，可以传入一段Unicode 编码来避免
Beautiful Soup 解析编码出错。</p>
</section>
<section id="id33">
<span id="id34"></span><h3>正则表达式<a class="headerlink" href="#id33" title="此标题的永久链接">¶</a></h3>
<p>如果传入正则表达式作为参数，Beautiful Soup 会通过正则表达式的 <code class="docutils literal notranslate"><span class="pre">match()</span></code> 来匹配内容。
下面例子中找出所有以 b 开头的标签，这种情况下 &lt;body&gt; 和 &lt;b&gt; 标签都会被找到:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^b&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># body</span>
<span class="c1"># b</span>
</pre></div>
</div>
<p>下面代码找出所有名字中包含 “t” 的标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># html</span>
<span class="c1"># title</span>
</pre></div>
</div>
</section>
<section id="id35">
<span id="id36"></span><h3>列表<a class="headerlink" href="#id35" title="此标题的永久链接">¶</a></h3>
<p>如果传入列表参数，Beautiful Soup会 将与列表中任一元素匹配的内容返回。
下面代码找到文档中所有 &lt;a&gt; 标签和 &lt;b&gt; 标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span>
<span class="c1"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</section>
<section id="true">
<span id="id37"></span><h3>True<a class="headerlink" href="#true" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> 可以匹配任何值，下面代码查找到所有的 tag，但是不会返回字符串节点</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># html</span>
<span class="c1"># head</span>
<span class="c1"># title</span>
<span class="c1"># body</span>
<span class="c1"># p</span>
<span class="c1"># b</span>
<span class="c1"># p</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># p</span>
</pre></div>
</div>
</section>
<section id="id38">
<span id="id39"></span><h3>函数<a class="headerlink" href="#id38" title="此标题的永久链接">¶</a></h3>
<p>如果没有合适过滤器，那么还可以定义一个函数方法，参数是一个元素 <a class="footnote-reference brackets" href="#id151" id="id40" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> ，
如果这个方法返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 表示当前元素匹配并且被找到，如果不是则反回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>下面方法实现的匹配功能是，如果包含 <code class="docutils literal notranslate"><span class="pre">class</span></code> 属性却不包含 <code class="docutils literal notranslate"><span class="pre">id</span></code> 属性，
那么将返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">has_class_but_no_id</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>将这个方法作为参数传入 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法，将得到所有 &lt;p&gt; 标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">has_class_but_no_id</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>返回结果中只有 &lt;p&gt; 标签，没有 &lt;a&gt; 标签，因为 &lt;a&gt; 标签还定义了”id”，
没有返回 &lt;html&gt; 和 &lt;head&gt;，因为 &lt;html&gt; 和 &lt;head&gt; 中没有定义 “class” 属性。</p>
<p>如果通过方法来筛选特殊属性，比如 <code class="docutils literal notranslate"><span class="pre">href</span></code>，传入方法的参数应该是对应属性的值，
而不是整个元素。下面的例子是找出那些 <code class="docutils literal notranslate"><span class="pre">a</span></code> 标签中的 <code class="docutils literal notranslate"><span class="pre">href</span></code> 属性不匹配指定正则:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">not_lacie</span><span class="p">(</span><span class="n">href</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">href</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;lacie&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">href</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">not_lacie</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>标签过滤方法可以使用复杂方法。下面的例子可以过滤出前后都有文字的标签。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">NavigableString</span>
<span class="k">def</span> <span class="nf">surrounded_by_strings</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">next_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">previous_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">))</span>

<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">surrounded_by_strings</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># p</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># p</span>
</pre></div>
</div>
<p>现在来了解一下搜索方法的细节</p>
</section>
</section>
<section id="find-all">
<h2>find_all()<a class="headerlink" href="#find-all" title="此标题的永久链接">¶</a></h2>
<p>find_all(<a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> , <a class="reference external" href="string">string</a> ,
<a class="reference external" href="kwargs">**kwargs</a> )</p>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法搜索当前 tag 的所有子节点，并判断是否符合过滤器的条件。
<a class="reference internal" href="#id29">过滤器类型</a> 中已经举过几个例子，这里再展示几个新例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;sisters&quot;</span><span class="p">))</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
</pre></div>
</div>
<p>有几个方法很相似，还有几个方法是新的，参数中的 <code class="docutils literal notranslate"><span class="pre">string</span></code> 和 <code class="docutils literal notranslate"><span class="pre">id</span></code> 是什么含义?
为什么 <code class="docutils literal notranslate"><span class="pre">find_all(&quot;p&quot;,</span> <span class="pre">&quot;title&quot;)</span></code> 返回的是CSS Class为”title”的&lt;p&gt;标签?
我们来仔细看一下 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 的参数</p>
<section id="name">
<span id="id42"></span><h3>name 参数<a class="headerlink" href="#name" title="此标题的永久链接">¶</a></h3>
<p>传一个值给 <code class="docutils literal notranslate"><span class="pre">name</span></code> 参数，就可以查找所有名字为 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的 tag。所有文本都会被忽略掉，
因为它们不匹配标签名字。</p>
<p>简单的用法如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>回忆 <a class="reference internal" href="#id29">过滤器类型</a> 中描述的内容，搜索 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的参数值可以是：
字符串、正则表达式、列表、方法或是 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。</p>
</section>
<section id="keyword">
<span id="id43"></span><h3>keyword 参数<a class="headerlink" href="#keyword" title="此标题的永久链接">¶</a></h3>
<p>如果动态参数中出现未能识别的参数名，搜索时会把该参数当作 tag 属性来搜索，
比如搜索参数中包含一个名字为 <code class="docutils literal notranslate"><span class="pre">id</span></code> 的参数，Beautiful Soup 会搜索每个
tag 上的 <code class="docutils literal notranslate"><span class="pre">id</span></code> 属性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link2&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>如果传入 <code class="docutils literal notranslate"><span class="pre">href</span></code> 参数，Beautiful Soup会搜索每个 tag 的 <code class="docutils literal notranslate"><span class="pre">href</span></code> 属性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;elsie&quot;</span><span class="p">))</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>搜索指定名字的属性时可以使用的参数值包括 <a class="reference internal" href="#id31">字符串</a> , <a class="reference internal" href="#id33">正则表达式</a> , <a class="reference internal" href="#id35">列表</a>, <a class="reference internal" href="#true">True</a> .</p>
<p>下面的例子在文档树中查找所有包含 <code class="docutils literal notranslate"><span class="pre">id</span></code> 属性的 tag，无论 <code class="docutils literal notranslate"><span class="pre">id</span></code> 的值是什么:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>使用多个指定名字的参数可以同时过滤多个 tag 属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;elsie&quot;</span><span class="p">),</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link1&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;three&lt;/a&gt;]</span>
</pre></div>
</div>
<p>有些 tag 属性在搜索不能使用，比如HTML5中的 data-* 属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#39;</span><span class="p">)</span>
<span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">foo</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="c1"># SyntaxError: keyword can&#39;t be an expression</span>
</pre></div>
</div>
<p>这种情况下可以通过 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法的 <code class="docutils literal notranslate"><span class="pre">attrs</span></code> 参数定义一个字典参数
来搜索包含特殊属性的 tag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data-foo&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span>
</pre></div>
</div>
<p>不要使用 “name” 作为关键字参数搜索 HTML 元素，因为 Beautiful Soup 用 <code class="docutils literal notranslate"><span class="pre">name</span></code>
来识别 tag 本身的名字。换一种方法，你可以这样搜索属性中的 “name” 值</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;input name=&quot;email&quot;/&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">name_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;email&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
<span class="n">name_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;email&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;input name=&quot;email&quot;/&gt;]</span>
</pre></div>
</div>
</section>
<section id="css">
<span id="attrs"></span><h3>按CSS搜索<a class="headerlink" href="#css" title="此标题的永久链接">¶</a></h3>
<p>按照 CSS 类名搜索的功能非常实用，但标识 CSS 类名的关键字 <code class="docutils literal notranslate"><span class="pre">class</span></code> 在Python中是保留字，
使用 <code class="docutils literal notranslate"><span class="pre">class</span></code> 做参数会导致语法错误。从 Beautiful Soup 4.1.2 版本开始，可以通过 <code class="docutils literal notranslate"><span class="pre">class_</span></code>
参数搜索有指定CSS类名的 tag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>作为关键字形式的参数 <code class="docutils literal notranslate"><span class="pre">class_</span></code> 同样接受不同类型的 <code class="docutils literal notranslate"><span class="pre">过滤器</span></code>，字符串、正则表达式、
方法或 <code class="docutils literal notranslate"><span class="pre">True</span></code> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;itl&quot;</span><span class="p">))</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="k">def</span> <span class="nf">has_six_characters</span><span class="p">(</span><span class="n">css_class</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">css_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">css_class</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">has_six_characters</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>tag 的 <code class="docutils literal notranslate"><span class="pre">class</span></code> 属性是 <a class="reference internal" href="#id13">多值属性</a> 。按照 CSS 类名搜索时，表示匹配到 tag 中任意 CSS 类名:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;strikeout&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>

<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>搜索 <code class="docutils literal notranslate"><span class="pre">class</span></code> 属性时也可以通过 CSS 值进行完全匹配:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;body strikeout&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>完全匹配 <code class="docutils literal notranslate"><span class="pre">class</span></code> 的值时，如果CSS类名的顺序与实际不符，将搜索不到结果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;strikeout body&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>如果想要通过多个 CSS 类型来搜索 tag，应该使用 CSS 选择器</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">css_soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p.strikeout.body&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>在旧版本的 Beautiful Soup 中，可能不支持 <code class="docutils literal notranslate"><span class="pre">class_</span></code>，这时可以使用 <code class="docutils literal notranslate"><span class="pre">attrs</span></code> 实现相同效果。
创建一个字典，包含要搜索的 class 类名（或者正则表达式等形式）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="s2">&quot;sister&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</section>
<section id="string2">
<span id="id44"></span><h3>string 参数<a class="headerlink" href="#string2" title="此标题的永久链接">¶</a></h3>
<p>通过 <code class="docutils literal notranslate"><span class="pre">string</span></code> 参数可以搜索文档中的字符串内容。与 <code class="docutils literal notranslate"><span class="pre">name</span></code> 参数接受的值一样，
<code class="docutils literal notranslate"><span class="pre">string</span></code> 参数接受 <a class="reference internal" href="#id31">字符串</a> , <a class="reference internal" href="#id33">正则表达式</a> , <a class="reference internal" href="#id35">列表</a>, <a class="reference internal" href="#id38">函数</a>, <a class="reference internal" href="#true">True</a> 。看例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Tillie&quot;</span><span class="p">,</span> <span class="s2">&quot;Elsie&quot;</span><span class="p">,</span> <span class="s2">&quot;Lacie&quot;</span><span class="p">])</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;Dormouse&quot;</span><span class="p">))</span>
<span class="p">[</span><span class="sa">u</span><span class="s2">&quot;The Dormouse&#39;s story&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;The Dormouse&#39;s story&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">is_the_only_string_within_a_tag</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="s2">&quot;&quot;</span><span class="n">Return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">this</span> <span class="n">string</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">only</span> <span class="n">child</span> <span class="n">of</span> <span class="n">its</span> <span class="n">parent</span> <span class="n">tag</span><span class="o">.</span><span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_the_only_string_within_a_tag</span><span class="p">)</span>
<span class="c1"># [u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;, u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;, u&#39;...&#39;]</span>
</pre></div>
</div>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">string</span></code> 参数用于搜索字符串，同时也以与其它参数混合使用来搜索 tag。
Beautiful Soup 会过滤那些 <code class="docutils literal notranslate"><span class="pre">string</span></code> 值与 <code class="docutils literal notranslate"><span class="pre">.string</span></code> 参数相符的 tag。
下面代码用来搜索内容里面包含 “Elsie” 的 &lt;a&gt; 标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> 参数是在 4.4.0 中新增的。早期版本中该参数名为 <code class="docutils literal notranslate"><span class="pre">text</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
</section>
<section id="limit">
<h3><code class="docutils literal notranslate"><span class="pre">limit</span></code> 参数<a class="headerlink" href="#limit" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法会返回全部的搜索结构，如果文档树很大那么搜索会很慢。
如果我们不需要全部结果，可以使用 <code class="docutils literal notranslate"><span class="pre">limit</span></code> 参数限制返回结果的数量。
效果与SQL中的limit关键字类似，当搜索到的结果数量达到 <code class="docutils literal notranslate"><span class="pre">limit</span></code> 的限制时，
就停止搜索返回结果。</p>
<p>“爱丽丝”文档例子中有 3 个 tag 符合搜索条件，但下面例子中的结果只返回了 2 个，
因为我们限制了返回数量:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
</section>
<section id="recursive2">
<span id="id45"></span><h3><code class="docutils literal notranslate"><span class="pre">recursive</span></code> 参数<a class="headerlink" href="#recursive2" title="此标题的永久链接">¶</a></h3>
<p>如果调用 <code class="docutils literal notranslate"><span class="pre">mytag.find_all()</span></code> 方法，Beautiful Soup 会检索 <code class="docutils literal notranslate"><span class="pre">mytag</span></code> 的所有子孙节点，
如果只想搜索直接子节点，可以使用参数 <code class="docutils literal notranslate"><span class="pre">recursive=False</span></code>。查看下面例子</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>下面一段简单的文档:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span>
   <span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story</span>
  <span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>&lt;title&gt; 标签在 &lt;html&gt; 标签之下，但并不是直接子节点，&lt;head&gt; 标签才是直接子节点。
在允许查询所有后代节点时 Beautiful Soup 能够查找到 &lt;title&gt; 标签。
但是使用了 <code class="docutils literal notranslate"><span class="pre">recursive=False</span></code>  参数之后，只能查找直接子节点，这样就查不到 &lt;title&gt; 标签了。</p>
<p>Beautiful Soup 提供了多种 DOM 树搜索方法。这些方法都使用了类似的参数定义。
比如这些方法: <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>: <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">attrs</span></code>, <code class="docutils literal notranslate"><span class="pre">text</span></code>, <code class="docutils literal notranslate"><span class="pre">limit</span></code>.
但是只有 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 支持 <code class="docutils literal notranslate"><span class="pre">recursive</span></code> 参数。</p>
</section>
</section>
<section id="find-all-tag">
<h2>像调用 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 一样调用tag<a class="headerlink" href="#find-all-tag" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 几乎是 Beautiful Soup 中最常用的搜索方法，所以我们定义了它的简写方法。
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象和 <code class="docutils literal notranslate"><span class="pre">Tag</span></code> 对象可以被当作一个方法来使用，这个方法的执行结果与
调用这个对象的 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法相同，下面两行代码是等价的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这两行代码也是等价的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="find">
<h2>find()<a class="headerlink" href="#find" title="此标题的永久链接">¶</a></h2>
<p>find(<a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> , <a class="reference external" href="string">string</a> ,
<a class="reference external" href="kwargs">**kwargs</a> )</p>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法将返回文档中符合条件的所有 tag，尽管有时候我们只想得到一个结果。
比如文档中只有一个 &lt;body&gt; 标签，那么使用 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法来查找 &lt;body&gt; 标签就
不太合适，使用 <code class="docutils literal notranslate"><span class="pre">find_all</span></code> 方法并设置 <code class="docutils literal notranslate"><span class="pre">limit=1</span></code> 参数不如直接使用  <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法。
下面两行代码是等价的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>唯一的区别是 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法的返回结果是值包含一个元素的列表，而 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法
直接返回结果。</p>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 方法没有找到目标是返回空列表， <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法找不到目标时，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;nosuchtag&quot;</span><span class="p">))</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">soup.head.title</span></code> 是 <a class="reference internal" href="#tag">Tag 的名字</a> 方法的简写。这个简写就是通过多次调用 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方
法实现的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;head&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
</section>
<section id="find-parents-find-parent">
<h2>find_parents() 和 find_parent()<a class="headerlink" href="#find-parents-find-parent" title="此标题的永久链接">¶</a></h2>
<p>find_parents( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>find_parent( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>我们已经用了很大篇幅来介绍 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法，Beautiful Soup 中
还有 10 个用于搜索的 API。它们中有 5 个用的是与 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 相同的搜索参数，
另外 5 个与 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法的搜索参数类似。区别仅是它们搜索文档的位置不同。</p>
<p>首先来看看 <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>。
记住: <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 只搜索当前节点的所有子节点，孙子节点等。
而这 2 个方法刚好相反，它们用来搜索当前节点的父辈节点。
我们来试试看，从例子文档中的一个深层叶子节点开始:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_string</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Lacie&quot;</span><span class="p">)</span>
<span class="n">a_string</span>
<span class="c1"># u&#39;Lacie&#39;</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parents</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="c1">#  and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parents</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>文档中的一个 &lt;a&gt; 标签是是当前叶子节点的直接父节点，所以可以被找到。
还有一个 &lt;p&gt; 标签，是目标叶子节点的间接父辈节点，所以也可以被找到。
包含 class 值为 “title” 的 &lt;p&gt; 标签不是不是目标叶子节点的父辈节点，
所以通过 <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> 方法搜索不到。</p>
<p><code class="docutils literal notranslate"><span class="pre">find_parent()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> 方法会让人联想到 <a class="reference internal" href="#parent">.parent</a> 和 <a class="reference internal" href="#parents">.parents</a> 属性。
它们之间的联系非常紧密。搜索父辈节点的方法实际上就是对 <code class="docutils literal notranslate"><span class="pre">.parents</span></code> 属性的迭代搜索。</p>
</section>
<section id="find-next-siblings-find-next-sibling">
<h2>find_next_siblings() 和 find_next_sibling()<a class="headerlink" href="#find-next-siblings-find-next-sibling" title="此标题的永久链接">¶</a></h2>
<p>find_next_siblings( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>find_next_sibling( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>这 2 个方法通过 <a class="reference external" href="sibling-generators">.next_siblings</a> 属性对当 tag 的所有后面解析 <a class="footnote-reference brackets" href="#id152" id="id61" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>
的兄弟tag节点进行迭代， <code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> 方法返回所有符合条件的后面的兄弟节点，
<code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code> 只返回符合条件的后面的第一个 tag 节点。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_next_sibling</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
</section>
<section id="find-previous-siblings-find-previous-sibling">
<h2>find_previous_siblings() 和 find_previous_sibling()<a class="headerlink" href="#find-previous-siblings-find-previous-sibling" title="此标题的永久链接">¶</a></h2>
<p>find_previous_siblings( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>find_previous_sibling( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>这 2 个方法通过 <a class="reference external" href="sibling-generators">.previous_siblings</a> 属性对当前 tag 的前面解析 <a class="footnote-reference brackets" href="#id152" id="id68" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>
的兄弟 tag 节点进行迭代， <code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code> 方法返回所有符合条件的前面的兄弟节点，
<code class="docutils literal notranslate"><span class="pre">find_previous_sibling()</span></code> 方法返回第一个符合条件的前面的兄弟节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">last_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_link</span><span class="o">.</span><span class="n">find_previous_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_previous_sibling</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
</section>
<section id="find-all-next-find-next">
<h2>find_all_next() 和 find_next()<a class="headerlink" href="#find-all-next-find-next" title="此标题的永久链接">¶</a></h2>
<p>find_all_next( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>find_next( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>这 2 个方法通过 <a class="reference external" href="element-generators">.next_elements</a> 属性对当前 tag 的之后的 <a class="footnote-reference brackets" href="#id152" id="id75" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>
tag 和字符串进行迭代， <code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> 方法返回所有符合条件的节点， <code class="docutils literal notranslate"><span class="pre">find_next()</span></code>
方法返回第一个符合条件的节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_next</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;,\n&#39;, u&#39;Lacie&#39;, u&#39; and\n&#39;, u&#39;Tillie&#39;,</span>
<span class="c1">#  u&#39;;\nand they lived at the bottom of a well.&#39;, u&#39;\n\n&#39;, u&#39;...&#39;, u&#39;\n&#39;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
<p>第一个例子中，字符串 “Elsie”也被显示出来，尽管它被包含在我们开始查找的 &lt;a&gt; 标签的里面。
第二个例子中，最后一个&lt;p&gt;标签也被显示出来，尽管它与我们开始查找位置的 &lt;a&gt; 标签不属于同一部分。
例子中，搜索的重点是要匹配过滤器的条件，以及元素在文档中出现的顺序要在查找的元素的之后。</p>
</section>
<section id="find-all-previous-find-previous">
<h2>find_all_previous() 和 find_previous()<a class="headerlink" href="#find-all-previous-find-previous" title="此标题的永久链接">¶</a></h2>
<p>find_all_previous( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>find_previous( <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> , <a class="reference external" href="recursive">recursive</a> ,
<a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> )</p>
<p>这 2 个方法通过 <a class="reference external" href="sibling-generators">.previous_elements</a> 属性对当前节点前面 <a class="footnote-reference brackets" href="#id152" id="id82" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> 的
tag 和字符串进行迭代， <code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> 方法返回所有符合条件的节点， <code class="docutils literal notranslate"><span class="pre">find_previous()</span></code>
方法返回第一个符合条件的节点。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_previous</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_previous</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">find_all_previous(&quot;p&quot;)</span></code> 既返回了文档中的第一段(class=”title”的那段)，还返回了第二段，
包含了我们开始查找的 &lt;a&gt; 标签的那段。不用惊讶，这段代码的功能是查找所有出现在指定 &lt;a&gt; 标签之前
的 &lt;p&gt; 标签，因为这个 &lt;p&gt; 标签包含了开始的 &lt;a&gt; 标签，所以 &lt;p&gt; 标签当然是在 &lt;a&gt; 之前出现的。</p>
</section>
<section id="id83">
<h2>CSS 选择器<a class="headerlink" href="#id83" title="此标题的永久链接">¶</a></h2>
<p>BeautifulSoup 对象和 Tag 对象支持通过 <code class="docutils literal notranslate"><span class="pre">.css</span></code> 属性实现 CSS 选择器。具体选择功能是通过
<a class="reference external" href="https://facelessuser.github.io/soupsieve/">Soup Sieve</a> 库实现的，在 PyPI 上通
过关键字 <code class="docutils literal notranslate"><span class="pre">soupsieve</span></code> 可以找到。通过 pip 安装 Beautiful Soup 时，Soup Sieve 也会自
动安装，不用其它额外操作。</p>
<p>Soup Sieve 文档列出了 <a class="reference external" href="https://facelessuser.github.io/soupsieve/selectors/">当前支持的 CSS 选择器</a>，
下面是一些基本应用</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p:nth-of-type(3)&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>查找指定层级的 tag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;body a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;html head title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>找到某个 tag 标签下的直接子标签 <a class="footnote-reference brackets" href="#id153" id="id85" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;head &gt; title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; a:nth-of-type(2)&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; #link1&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;body &gt; a&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>找到兄弟节点标签:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1 ~ .sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot;  id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1 + .sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>通过 CSS 的类名查找:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;[class~=sister]&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>通过 id 查找 tag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;a#link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>查找符合列表中任意一个选择器的 tag：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1,#link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>通过是否存在某个属性来查找:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>通过属性的值来查找:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href=&quot;http://example.com/elsie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href^=&quot;http://example.com/&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href$=&quot;tillie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href*=&quot;.com/el&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>还有一个 <code class="docutils literal notranslate"><span class="pre">select_one()</span></code> 方法，它会返回符合筛选条件的元素列表中的第一个</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select_one</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>为了方便使用，在 BeautifulSoup 或 Tag 对象上直接调用 <code class="docutils literal notranslate"><span class="pre">select()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">select_one()</span></code> 方法，
中间省略 <code class="docutils literal notranslate"><span class="pre">.css</span></code> 属性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href$=&quot;tillie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select_one</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>CSS 选择器对于熟悉 CSS 语法的人来说非常方便。你可以在 Beautiful Soup 中使用相同的方法。
但是如果你只需要使用 CSS 选择器就够了，那么应该 <code class="docutils literal notranslate"><span class="pre">lxml</span></code> 作为文档解析器：因为速度快很多。
但是 Soup Sieve 也有优势，它允许 <cite>组合</cite> 使用 CSS 选择器和 Beautiful Soup 的 API。</p>
</section>
<section id="id86">
<h2>Soup Sieve 高级特性<a class="headerlink" href="#id86" title="此标题的永久链接">¶</a></h2>
<p>Soup Sieve 提供的是比 <code class="docutils literal notranslate"><span class="pre">select()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">select_one()</span></code> 更底层的方法，通过 Tag 或
Beautiful Soup 对象的 <code class="docutils literal notranslate"><span class="pre">.css</span></code> 属性，可以调用大部分的 API。下面是支持这种调用方式的方法列表，
查看 <a class="reference external" href="https://facelessuser.github.io/soupsieve/">Soup Sieve</a> 文档了解全部细节。</p>
<p><code class="docutils literal notranslate"><span class="pre">iselect()</span></code> 方法与 <code class="docutils literal notranslate"><span class="pre">select()</span></code> 效果相同，区别是返回的结果是迭代器。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">iselect</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)]</span>
<span class="c1"># [&#39;link1&#39;, &#39;link2&#39;, &#39;link3&#39;]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">closest()</span></code> 方法与 <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code> 方法相似，返回符合 CSS 选择器的 Tag 对象的最近父级。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">elsie</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select_one</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="n">elsie</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="s2">&quot;p.story&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="c1">#  and they lived at the bottom of a well.&lt;/p&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">match()</span></code> 方法返回布尔结果，标记指定 Tag 是否符合指定筛选器</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># elsie.css.match(&quot;#link1&quot;)</span>
<span class="kc">True</span>

<span class="c1"># elsie.css.match(&quot;#link2&quot;)</span>
<span class="kc">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">filter()</span></code> 方法返回 tag 直接子节点中符合筛选器的节点列表</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;story&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)]</span>
<span class="c1"># [&#39;Elsie&#39;, &#39;Lacie&#39;, &#39;Tillie&#39;]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">escape()</span></code> 方法可以对 CSS 标识符中的特殊字符进行转义，否则是非法 CSS 标识符</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;1-strange-identifier&quot;</span><span class="p">)</span>
<span class="c1"># &#39;\\31 -strange-identifier&#39;</span>
</pre></div>
</div>
</section>
<section id="id88">
<h2>CSS 筛选器中的命名空间<a class="headerlink" href="#id88" title="此标题的永久链接">¶</a></h2>
<p>如果解析的 XML 文档中定义了命名空间，那么 CSS 筛选器中也可以使用</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">xml</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&lt;tag xmlns:ns1=&quot;http://namespace1/&quot; xmlns:ns2=&quot;http://namespace2/&quot;&gt;</span>
<span class="s2">&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;</span>
<span class="s2">&lt;ns2:child&gt;I&#39;m in namespace 2&lt;/ns2:child&gt;</span>
<span class="s2">&lt;/tag&gt; &quot;&quot;&quot;</span>
<span class="n">namespace_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>

<span class="n">namespace_soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;, &lt;ns2:child&gt;I&#39;m in namespace 2&lt;/ns2:child&gt;]</span>

<span class="n">namespace_soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;ns1|child&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;]</span>
</pre></div>
</div>
<p>Beautiful Soup 尝试自动匹配解析文档中的命名空间前缀，除此之外，你还可以自定义目录的缩写</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="s2">&quot;http://namespace1/&quot;</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s2">&quot;http://namespace2/&quot;</span><span class="p">)</span>
<span class="n">namespace_soup</span><span class="o">.</span><span class="n">css</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;second|child&quot;</span><span class="p">,</span> <span class="n">namespaces</span><span class="o">=</span><span class="n">namespaces</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 2&lt;/ns1:child&gt;]</span>
</pre></div>
</div>
</section>
<section id="id89">
<h2>支持 CSS 筛选器的历史版本<a class="headerlink" href="#id89" title="此标题的永久链接">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">.css</span></code> 属性是在 Beautiful Soup 4.12.0 中添加的。在此之前，只能使用 <code class="docutils literal notranslate"><span class="pre">.select()</span></code> 和</dt><dd><p><code class="docutils literal notranslate"><span class="pre">.select_one()</span></code> 方法。</p>
</dd>
</dl>
<p>Soup Sieve 是在 Beautiful Soup 4.7.0 开始集成的。早期版本中有 <code class="docutils literal notranslate"><span class="pre">.select()</span></code> 方法，但
仅能支持最常用的 CSS 选择器。</p>
</section>
</section>
<section id="id90">
<h1>修改文档树<a class="headerlink" href="#id90" title="此标题的永久链接">¶</a></h1>
<p>Beautiful Soup 的强项是文档树的搜索，但也支持修改文档数，或者编写新的 HTML、XML 文档。</p>
<section id="id91">
<h2>修改 tag 的名称和属性<a class="headerlink" href="#id91" title="此标题的永久链接">¶</a></h2>
<p>在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Tag.attrs</span></code> 的章节中已经介绍过这个功能，但是再看一遍也无妨。重命名一个 tag,
改变属性的值，添加或删除属性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>

<span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blockquote&quot;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
</section>
<section id="id92">
<h2>修改 <code class="docutils literal notranslate"><span class="pre">.string</span></code><a class="headerlink" href="#id92" title="此标题的永久链接">¶</a></h2>
<p>如果设置 tag 的 <code class="docutils literal notranslate"><span class="pre">.string</span></code> 属性值，就相当于用新的内容替代了原来的内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>

<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;New link text.&quot;</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;New link text.&lt;/a&gt;</span>
</pre></div>
</div>
<p>注意：如果 tag 原本包含了其它子节点，原有的所有内容包括子 tag 都会被覆盖掉。</p>
</section>
<section id="append">
<h2><code class="docutils literal notranslate"><span class="pre">append()</span></code><a class="headerlink" href="#append" title="此标题的永久链接">¶</a></h2>
<p>向 tag 中添加内容可以使用 <code class="docutils literal notranslate"><span class="pre">Tag.append()</span></code> 方法，就好像调用 Python 列表的 <code class="docutils literal notranslate"><span class="pre">.append()</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;Foo&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Bar&quot;</span><span class="p">)</span>

<span class="n">soup</span>
<span class="c1"># &lt;a&gt;FooBar&lt;/a&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;Foo&#39;, &#39;Bar&#39;]</span>
</pre></div>
</div>
</section>
<section id="extend">
<h2><code class="docutils literal notranslate"><span class="pre">extend()</span></code><a class="headerlink" href="#extend" title="此标题的永久链接">¶</a></h2>
<p>从 Beautiful Soup 4.7.0 版本开始，tag 增加了 <code class="docutils literal notranslate"><span class="pre">.extend()</span></code> 方法，可以把一个列表中内容，
按顺序全部添加到一个 tag 当中</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;Soup&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;&#39;s&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">])</span>

<span class="n">soup</span>
<span class="c1"># &lt;a&gt;Soup&#39;s on&lt;/a&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;Soup&#39;, &#39;&#39;s&#39;, &#39; &#39;, &#39;on&#39;]</span>
</pre></div>
</div>
</section>
<section id="navigablestring-new-tag">
<h2>NavigableString() 和 .new_tag()<a class="headerlink" href="#navigablestring-new-tag" title="此标题的永久链接">¶</a></h2>
<p>如果想添加一段文本内容到文档中，可以将一个 Python 字符串对象传给 <code class="docutils literal notranslate"><span class="pre">append()</span></code> 方法，
或调用 <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> 构造方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">NavigableString</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="n">new_string</span> <span class="o">=</span> <span class="n">NavigableString</span><span class="p">(</span><span class="s2">&quot; there&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_string</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;Hello there.&lt;/b&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;Hello&#39;, &#39; there&#39;]</span>
</pre></div>
</div>
<p>如果想要创建一段注释，或其它 <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> 的子类，只要调用构造方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">Comment</span>
<span class="n">new_comment</span> <span class="o">=</span> <span class="n">Comment</span><span class="p">(</span><span class="s2">&quot;Nice to see you.&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comment</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;Hello&#39;, &#39; there&#39;, &#39;Nice to see you.&#39;]</span>
</pre></div>
</div>
<p><cite>(这是 Beautiful Soup 4.4.0 中新增的方法)</cite></p>
<p>如果需要新创建一个 tag，最好的方法是调用工厂方法 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup.new_tag()</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">original_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>

<span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://www.example.com&quot;</span><span class="p">)</span>
<span class="n">original_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
<span class="n">original_tag</span>
<span class="c1"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;&lt;/a&gt;&lt;/b&gt;</span>

<span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Link text.&quot;</span>
<span class="n">original_tag</span>
<span class="c1"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span>
</pre></div>
</div>
<p>只有第一个参数用作 tag 的 name，是必填的。</p>
</section>
<section id="insert">
<h2>insert()<a class="headerlink" href="#insert" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.insert()</span></code> 方法与 <code class="docutils literal notranslate"><span class="pre">Tag.append()</span></code> 方法类似，区别是不会把新元素添加到
父节点 <code class="docutils literal notranslate"><span class="pre">.contents</span></code> 属性的最后。而是把元素插入到按顺序指定的位置。与 Python 列表
中的 <code class="docutils literal notranslate"><span class="pre">.insert()</span></code> 方法的用法相同</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">tag</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;but did not endorse &quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;I linked to &#39;, &#39;but did not endorse&#39;, &lt;i&gt;example.com&lt;/i&gt;]</span>
</pre></div>
</div>
</section>
<section id="insert-before-insert-after">
<h2>insert_before() 和 insert_after()<a class="headerlink" href="#insert-before-insert-after" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> 方法可以在文档树中直接在目标之前添加 tag 或文本</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;leave&lt;/b&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Don&#39;t&quot;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">insert_before</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;&lt;i&gt;Don&#39;t&lt;/i&gt;leave&lt;/b&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">insert_after()</span></code> 方法可以在文档树中直接在目标之后添加 tag 或文本</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">div</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
<span class="n">div</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;ever&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">insert_after</span><span class="p">(</span><span class="s2">&quot; you &quot;</span><span class="p">,</span> <span class="n">div</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;&lt;i&gt;Don&#39;t&lt;/i&gt; you &lt;div&gt;ever&lt;/div&gt; leave&lt;/b&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;i&gt;Don&#39;t&lt;/i&gt;, &#39; you&#39;, &lt;div&gt;ever&lt;/div&gt;, &#39;leave&#39;]</span>
</pre></div>
</div>
</section>
<section id="clear">
<h2>clear()<a class="headerlink" href="#clear" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.clear()</span></code> 方法可以移除 tag 的内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">tag</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;&lt;/a&gt;</span>
</pre></div>
</div>
</section>
<section id="extract">
<h2>extract()<a class="headerlink" href="#extract" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.extract()</span></code> 方法将当前 tag 或文本从文档树中移除，并返回被删除的内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">i_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span>

<span class="n">i_tag</span>
<span class="c1"># &lt;i&gt;example.com&lt;/i&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">i_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>这个方法实际上产生了 2 个文档树: 一个是原始文档的 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象，
另一个是被移除并且返回的文档树。还可以在新生成的文档树上继续调用 <code class="docutils literal notranslate"><span class="pre">extract</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_string</span> <span class="o">=</span> <span class="n">i_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
<span class="n">my_string</span>
<span class="c1"># &#39;example.com&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">my_string</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
<span class="n">i_tag</span>
<span class="c1"># &lt;i&gt;&lt;/i&gt;</span>
</pre></div>
</div>
</section>
<section id="decompose">
<h2>decompose()<a class="headerlink" href="#decompose" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.decompose()</span></code> 方法会将前节点从文档书中移除并完全销毁:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">i_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">i</span>

<span class="n">i_tag</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>
<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span>
</pre></div>
</div>
<p>被 decompose 的 Tag 或者 <cite>NavigableString</cite> 是不稳定的，什么时候都不要使用它。如果不确定
某些内容是否被 decompose 了，可以通过 <code class="docutils literal notranslate"><span class="pre">.decomposed</span></code> 属性进行检查 <cite>(Beautiful Soup 4.9.0 新增)</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">i_tag</span><span class="o">.</span><span class="n">decomposed</span>
<span class="c1"># True</span>

<span class="n">a_tag</span><span class="o">.</span><span class="n">decomposed</span>
<span class="c1"># False</span>
</pre></div>
</div>
</section>
<section id="replace-with">
<span id="id93"></span><h2>replace_with()<a class="headerlink" href="#replace-with" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.replace_with()</span></code> 方法移除文档树中的某段内容，并用新 tag 或文本节点替代它:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;example.com&quot;</span>
<span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;b&gt;example.com&lt;/b&gt;&lt;/a&gt;</span>

<span class="n">bold_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">bold_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;example&quot;</span>
<span class="n">i_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
<span class="n">i_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;net&quot;</span>
<span class="n">a_tag</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">bold_tag</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">i_tag</span><span class="p">)</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;b&gt;example&lt;/b&gt;.&lt;i&gt;net&lt;/i&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code> 方法返回被替代的 tag 或文本节点，可以用来检查或添加到文档树其它地方。</p>
<p><cite>传递多个参数给 replace_with() 方法在 Beautiful Soup 4.10.0 版本中新增</cite></p>
</section>
<section id="wrap">
<h2>wrap()<a class="headerlink" href="#wrap" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.wrap()</span></code> 方法可以对指定的tag元素进行包装 <a class="footnote-reference brackets" href="#id155" id="id94" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> ，并返回包装后的结果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;I wish I was bold.&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
<span class="c1"># &lt;b&gt;I wish I was bold.&lt;/b&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">))</span>
<span class="c1"># &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span>
</pre></div>
</div>
<p>该方法在 Beautiful Soup 4.0.5 中添加。</p>
</section>
<section id="unwrap">
<h2>unwrap()<a class="headerlink" href="#unwrap" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.unwrap()</span></code> 方法与 <code class="docutils literal notranslate"><span class="pre">wrap()</span></code> 方法相反。它将用 tag 内内容来替换 tag 本身，
该方法常被用来解包内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span>
<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to example.com&lt;/a&gt;</span>
</pre></div>
</div>
<p>与 <code class="docutils literal notranslate"><span class="pre">replace_with()</span></code> 方法相同，<code class="docutils literal notranslate"><span class="pre">unwrap()</span></code> 方法会返回被移除的 tag。</p>
</section>
<section id="smooth">
<h2>smooth()<a class="headerlink" href="#smooth" title="此标题的永久链接">¶</a></h2>
<p>调用了一堆修改文档树的方法后，可能剩下的是 2 个或更多个彼此衔接的 NavigableString 对象。
Beautiful Soup 处理起来没有问题，但在刚刚解析的文档树中，可能会出现非预期情况</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;A one&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, a two&quot;</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;A one&#39;, &#39;, a two&#39;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># b&#39;&lt;p&gt;A one, a two&lt;/p&gt;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  A one</span>
<span class="c1">#  , a two</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p>这时可以使用 <code class="docutils literal notranslate"><span class="pre">Tag.smooth()</span></code> 方法来清理文档树，把相邻的字符串平滑的链接到一起</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">smooth</span><span class="p">()</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&#39;A one, a two&#39;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  A one, a two</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p>该方法在 Beautiful Soup 4.8.0 中添加。</p>
</section>
</section>
<section id="id95">
<h1>输出<a class="headerlink" href="#id95" title="此标题的永久链接">¶</a></h1>
<section id="id96">
<h2>格式化输出<a class="headerlink" href="#id96" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">prettify()</span></code> 方法将 Beautiful Soup 的文档树格式化后以 Unicode 编码输出，
每个 XML/HTML 标签都独占一行</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">()</span>
<span class="c1"># &#39;&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href=&quot;http://example.com/&quot;&gt;\n...&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;a href=&quot;http://example.com/&quot;&gt;</span>
<span class="c1">#    I linked to</span>
<span class="c1">#    &lt;i&gt;</span>
<span class="c1">#     example.com</span>
<span class="c1">#    &lt;/i&gt;</span>
<span class="c1">#   &lt;/a&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象的根节点和它的所有 tag 节点都可以调用 <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;</span>
<span class="c1">#  I linked to</span>
<span class="c1">#  &lt;i&gt;</span>
<span class="c1">#   example.com</span>
<span class="c1">#  &lt;/i&gt;</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
<p>因为格式化会添加额外的空格（为了换行显示），因为 <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> 会改变 HTML 文档的内容，
所以不要用来格式化文档。 <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> 方法的设计目标是为了帮助更好的显示和理解文档。</p>
</section>
<section id="id97">
<h2>压缩输出<a class="headerlink" href="#id97" title="此标题的永久链接">¶</a></h2>
<p>如果只想得到结果字符串，不重视格式，那么可以对一个 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象或 <code class="docutils literal notranslate"><span class="pre">Tag</span></code> 对象
使用 Python 的 <code class="docutils literal notranslate"><span class="pre">unicode()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">str()</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># &#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># &#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">str()</span></code> 方法返回 UTF-8 编码的字符串，查看定 <a class="reference internal" href="#id103">编码</a> 了解更多选项。</p>
<p>还可以调用 <code class="docutils literal notranslate"><span class="pre">encode()</span></code> 方法获得字节码或调用 <code class="docutils literal notranslate"><span class="pre">decode()</span></code> 方法获得Unicode。</p>
</section>
<section id="id98">
<h2>输出格式<a class="headerlink" href="#id98" title="此标题的永久链接">¶</a></h2>
<p>Beautiful Soup 输出是会将 HTML 中的特殊字符编码转换成 Unicode, 比如 “&amp;lquot;”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># &#39;“Dammit!” he said.&#39;</span>
</pre></div>
</div>
<p>如果将文档转换成字节编码，那么字节码 Unicode 会被编码成 UTF-8。并且无法再转换回 html 中的特殊字符编码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span>
<span class="c1"># b&#39;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&#39;</span>
</pre></div>
</div>
<p>默认情况下，只会转义 &amp; 符号和尖角号。它们会被转义为 “&amp;amp;”，”&amp;lt;” 和 “&amp;gt;”，因此 Beautiful Soup
不会无意间生成错误格式的的 HTML 或 XML</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;The law firm of Dewey, Cheatem, &amp; Howe&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c1"># &lt;p&gt;The law firm of Dewey, Cheatem, &amp;amp; Howe&lt;/p&gt;</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a href=&quot;http://example.com/?foo=val1&amp;amp;bar=val2&quot;&gt;A link&lt;/a&gt;</span>
</pre></div>
</div>
<p>修改默认转义规则的方法是，设置 <code class="docutils literal notranslate"><span class="pre">prettify()</span></code>, <code class="docutils literal notranslate"><span class="pre">encode()</span></code>, 或 <code class="docutils literal notranslate"><span class="pre">decode()</span></code> 方法的 <code class="docutils literal notranslate"><span class="pre">formatter</span></code>
参数。Beautiful Soup 可以识别 5 种 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 值。</p>
<p>默认的设置是 <code class="docutils literal notranslate"><span class="pre">formatter=&quot;minimal&quot;</span></code>。处置字符串时 Beautiful Soup 会确保生成合法的 HTML/XML</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">french</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">french</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;minimal&quot;</span><span class="p">))</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  Il a dit &amp;lt;&amp;lt;Sacré bleu!&amp;gt;&amp;gt;</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p>设置为 <code class="docutils literal notranslate"><span class="pre">formatter=&quot;html&quot;</span></code> 时，Beautiful Soup 会尽可能把 Unicode 字符转换为 HTML 实体</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p>设置为 <code class="docutils literal notranslate"><span class="pre">formatter=&quot;html5&quot;</span></code> 时，结果与 <code class="docutils literal notranslate"><span class="pre">formatter=&quot;html&quot;</span></code> 相似，区别是 Beautiful Soup
会忽略 HTML 标签种空标签里的斜杠符号，比如 “br” 标签</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">br</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">br</span>

<span class="nb">print</span><span class="p">(</span><span class="n">br</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;br/&gt;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">br</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html5&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;br&gt;&#39;</span>
</pre></div>
</div>
<p>另外，如果属性的值为空字符串的，它会变为 HTML 风格的 boolean 属性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">option</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;option selected=&quot;&quot;&gt;&lt;/option&gt;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">option</span>
<span class="nb">print</span><span class="p">(</span><span class="n">option</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;option selected=&quot;&quot;&gt;&lt;/option&gt;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">option</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html5&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;option selected&gt;&lt;/option&gt;&#39;</span>
</pre></div>
</div>
<p>这种机制在 Beautiful Soup 4.10.0 中添加。</p>
<p>设置为 <code class="docutils literal notranslate"><span class="pre">formatter=None</span></code> 时，Beautiful Soup 在输出时不会修改任何字符串内容。这是效率最高的选项，
但可能导致输出非法的 HTML/XML，比如下面例子</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  Il a dit &lt;&lt;Sacré bleu!&gt;&gt;</span>
<span class="c1"># &lt;/p&gt;</span>

<span class="n">link_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span>
</pre></div>
</div>
</section>
<section id="id99">
<h2>格式化对象<a class="headerlink" href="#id99" title="此标题的永久链接">¶</a></h2>
<p>如果需要更复杂的机制来控制输出内容，可以实例化 Beautiful Soup 的 formatter 实例，
然后用作 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 参数。</p>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.HTMLFormatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">HTMLFormatter</span></span><a class="headerlink" href="#bs4.HTMLFormatter" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>可以用来自定义 HTML 文档的格式化规则。</p>
<p>下面的 formatter 例子，可以将字符串全部转化为大写，不论是文字节点中的字符还是属性值</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.formatter</span> <span class="kn">import</span> <span class="n">HTMLFormatter</span>
<span class="k">def</span> <span class="nf">uppercase</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

<span class="n">formatter</span> <span class="o">=</span> <span class="n">HTMLFormatter</span><span class="p">(</span><span class="n">uppercase</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  IL A DIT &lt;&lt;SACRÉ BLEU!&gt;&gt;</span>
<span class="c1"># &lt;/p&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;a href=&quot;HTTP://EXAMPLE.COM/?FOO=VAL1&amp;BAR=VAL2&quot;&gt;</span>
<span class="c1">#  A LINK</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
<p>下面的 formatter 例子，在美化文档时增加缩进长度</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">formatter</span> <span class="o">=</span> <span class="n">HTMLFormatter</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;</span>
<span class="c1">#         A link</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="bs4.XMLFormatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bs4.</span></span><span class="sig-name descname"><span class="pre">XMLFormatter</span></span><a class="headerlink" href="#bs4.XMLFormatter" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>可以用来自定义 XML 文档的格式化规则。</p>
</section>
<section id="formatter">
<h2>编写自定义 formatter<a class="headerlink" href="#formatter" title="此标题的永久链接">¶</a></h2>
<p><a class="reference internal" href="#bs4.HTMLFormatter" title="bs4.HTMLFormatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLFormatter</span></code></a> or <a class="reference internal" href="#bs4.XMLFormatter" title="bs4.XMLFormatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLFormatter</span></code></a> 的子类可以控制更多的输出过程。
例如，Beautiful Soup 默认情况下会对属性中的 tag 进行排序</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">attr_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&lt;p z=&quot;1&quot; m=&quot;2&quot; a=&quot;3&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">attr_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># &lt;p a=&quot;3&quot; m=&quot;2&quot; z=&quot;1&quot;&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>若想关闭这个功能，可以使用子类的 <code class="docutils literal notranslate"><span class="pre">Formatter.attributes()</span></code> 方法，该方法可以控制输出那些属性
以及这些属性的输出顺序。下面的例子会过滤掉文档中的 “m” 属性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UnsortedAttributes</span><span class="p">(</span><span class="n">HTMLFormatter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

<span class="nb">print</span><span class="p">(</span><span class="n">attr_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">UnsortedAttributes</span><span class="p">()))</span>
<span class="c1"># &lt;p z=&quot;1&quot; a=&quot;3&quot;&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>危险提示：如果创建了 <cite>CData</cite> 对象，对象中的字符串对象始终表示原始内容，不会被格式化方法影响。
Beautiful Soup 输出时依然会调用自定义格式化方法，以防自定义方法中包含自定义的字符串计数方法，
但调用后不会使用返回结果，不影响原来的返回值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.element</span> <span class="kn">import</span> <span class="n">CData</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s2">&quot;one &lt; three&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># &lt;a&gt;</span>
<span class="c1">#  &lt;![CDATA[one &lt; three]]&gt;</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
</section>
<section id="get-text">
<h2>get_text()<a class="headerlink" href="#get-text" title="此标题的永久链接">¶</a></h2>
<p>如果只想得到 tag 中包含的文本内容，那么可以调用 <code class="docutils literal notranslate"><span class="pre">get_text()</span></code> 方法，这个方法获取到 tag
包含的所有文本内容，包括子孙 tag 中的可读内容，并将结果作为单独的一个 Unicode 编码字符串返回:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;</span><span class="se">\n</span><span class="s1">I linked to &lt;i&gt;example.com&lt;/i&gt;</span><span class="se">\n</span><span class="s1">&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="s1">&#39;</span><span class="se">\n</span><span class="s1">I linked to example.com</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="s1">&#39;example.com&#39;&#39;</span>
</pre></div>
</div>
<p>可以通过参数指定 tag 的文本内容的连接符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># soup.get_text(&quot;|&quot;)</span>
<span class="s1">&#39;</span><span class="se">\n</span><span class="s1">I linked to |example.com|</span><span class="se">\n</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>还可以去除每一个文本片段内容的前后空白:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># soup.get_text(&quot;|&quot;, strip=True)</span>
<span class="s1">&#39;I linked to|example.com&#39;</span>
</pre></div>
</div>
<p>但这种情况，你可能应该使用 <a class="reference external" href="string-generators">.stripped_strings</a> 生成器，
获得文本列表后手动处理内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">text</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">]</span>
<span class="c1"># [&#39;I linked to&#39;, &#39;example.com&#39;]</span>
</pre></div>
</div>
<p><em>因为 Beautiful Soup 4.9.0 版本开始使用 lxml 或 html.parser，&lt;script&gt;，&lt;style&gt; 和
&lt;template&gt; 标签中的内容不会被当做普通的 ‘文本’ 来处理，因此这些标签中的内容不会算作页面中的
可读内容的一部分。</em></p>
<p><em>Beautiful Soup 4.10.0 版本以后，可以在 NavigableString 对象上调用 get_text()，.strings
或 .stripped_strings 属性，结果会返回对象本身或空，这种用法只有在对混合类型列表迭代时才会用到。</em></p>
</section>
</section>
<section id="id100">
<h1>指定文档解析器<a class="headerlink" href="#id100" title="此标题的永久链接">¶</a></h1>
<p>如果仅是想要解析HTML文档，只需要创建 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象时传入文档就可以了。Beautiful Soup
会自动选择一个解析器来解析文档。同时还可以使用额外参数，来指定文档解析器。</p>
<p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 第一个参数应该是要被解析的文档字符串或是文件句柄 – 待解析文件的句柄，
第二个参数用来标识怎样解析文档。</p>
<p>如果不指定解析器，默认使用已安装的 <cite>最佳</cite> HTML 解析器。Beautiful Soup 把 lxml 解析器排在第一,
然后是 html5lib, 然后是 Python 标准库。在下面两种条件下解析器优先顺序会变化:</p>
<blockquote>
<div><ul class="simple">
<li><p>要解析的文档是什么类型: 目前支持， “html”，“xml”，和 “html5”</p></li>
<li><p>指定使用哪种解析器: 目前支持，“lxml”，“html5lib”，和 “html.parser”（Python 标准库）</p></li>
</ul>
</div></blockquote>
<p><a class="reference internal" href="#id10">安装解析器</a> 章节介绍了可以使用哪种解析器，以及如何安装。</p>
<p>如果指定的解析器没有安装，Beautiful Soup会自动选择其它方案。目前只有 lxml 解析器支持XML文档的解析，
在没有安装 lxml 库的情况下，无法自动选择 XML 文档解析器，手动指定 lxml 也不行。</p>
<section id="id101">
<h2>解析器之间的区别<a class="headerlink" href="#id101" title="此标题的永久链接">¶</a></h2>
<p>Beautiful Soup 为不同的解析器提供了相同的接口，但解析器本身时有区别的。同一篇文档被不同的解析器解析后
可能会生成不同结构的文档。区别最大的是 HTML 解析器和 XML 解析器，看下面片段被解析成 HTML 结构:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>因为空标签 &lt;b /&gt; 不符合 HTML 标准，html.parser 解析器把它解析成一对儿 &lt;b&gt;&lt;/b&gt;。</p>
<p>同样的文档使用 XML 解析结果如下(解析 XML 需要安装 lxml 库)。注意，空标签 &lt;b /&gt; 依然被保留，
并且文档前添加了 XML 头，而不是被包含在 &lt;html&gt; 标签内:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">))</span>
<span class="c1"># &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="c1"># &lt;a&gt;&lt;b/&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>HTML 解析器之间也有区别，如果被解析的HTML文档是标准格式，那么解析器之间没有任何差别。
只是解析速度不同，结果都会返回正确的文档树。</p>
<p>但是如果被解析文档不是标准格式，那么不同的解析器返回结果可能不同。下面例子中，使用 lxml
解析错误格式的文档，结果 &lt;/p&gt; 标签被直接忽略掉了:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>使用 html5lib 库解析相同文档会得到不同的结果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html5lib&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>html5lib 库没有忽略掉 &lt;/p&gt; 标签，而是自动补全了标签，还给文档树添加了 &lt;head&gt; 标签。</p>
<p>使用 pyhton 内置库解析结果如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>与 lxml <a class="footnote-reference brackets" href="#id154" id="id102" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> 库类似的，Python 内置库忽略掉了 &lt;/p&gt; 标签，与 html5lib 库不同的是标准库没有
尝试创建符合标准的文档格式或将文档片段包含在 &lt;body&gt; 标签内，与lxml不同的是标准库甚至连 &lt;html&gt;
标签都没有尝试去添加。</p>
<p>因为文档片段 “&lt;a&gt;&lt;/p&gt;” 是错误格式，所以以上解析方式都能算作 “正确”，html5lib 库使用的是 HTML5
的部分标准，所以最接近”正确”。不过所有解析器的结构都能够被认为是”正常”的。</p>
<p>不同的解析器可能影响代码执行结果，如果在分发给别人的代码中使用了 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> ,
那么最好注明使用了哪种解析器，以减少不必要的麻烦。</p>
</section>
</section>
<section id="id103">
<h1>编码<a class="headerlink" href="#id103" title="此标题的永久链接">¶</a></h1>
<p>任何 HTML 或 XML 文档都有自己的编码方式，比如ASCII 或 UTF-8。但是使用 Beautiful Soup 解析后，
文档都被转换成了 Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;h1&gt;Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!&lt;/h1&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="c1"># &lt;h1&gt;Sacré bleu!&lt;/h1&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># &#39;Sacr\xe9 bleu!&#39;</span>
</pre></div>
</div>
<p>这不是魔术(但很神奇)，Beautiful Soup 用了 <a class="reference external" href="Unicode,Dammit">编码自动检测</a> 子库来识别当前
文档编码并转换成 Unicode 编码。<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">.original_encoding</span></code> 属性记录了
自动识别编码的结果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;utf-8&#39;</span>
</pre></div>
</div>
<p><a class="reference external" href="Unicode,Dammit">编码自动检测</a> 功能大部分时候都能猜对编码格式，但有时候也会出错。有时候即使
猜测正确，也是在逐个 字节的遍历整个文档后才猜对的，这样很慢。如果预先知道文档编码，可以设置编码参数
来减少自动检查编码 出错的概率并且提高文档解析速度。在创建 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象的时候设置
<code class="docutils literal notranslate"><span class="pre">from_encoding</span></code> 参数。</p>
<p>下面一段文档用了 ISO-8859-8 编码方式，这段文档太短，结果 Beautiful Soup 以为文档是用 ISO-8859-7 编码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&lt;h1&gt;</span><span class="se">\xed\xe5\xec\xf9</span><span class="s2">&lt;/h1&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="p">)</span>
<span class="c1"># &lt;h1&gt;νεμω&lt;/h1&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span><span class="p">)</span>
<span class="c1"># iso-8859-7</span>
</pre></div>
</div>
<p>通过传入 <code class="docutils literal notranslate"><span class="pre">from_encoding</span></code> 参数来指定编码方式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">from_encoding</span><span class="o">=</span><span class="s2">&quot;iso-8859-8&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="p">)</span>
<span class="c1"># &lt;h1&gt;םולש&lt;/h1&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span><span class="p">)</span>
<span class="c1"># iso8859-8</span>
</pre></div>
</div>
<p>如果仅知道文档采用了 Unicode 编码，但不知道具体编码。可以先自己猜测，猜测错误(依旧是乱码)时，
可以把错误编码作为 <code class="docutils literal notranslate"><span class="pre">exclude_encodings</span></code> 参数，这样文档就不会尝试使用这种编码了解码了。</p>
<p>译者备注: 在没有指定编码的情况下，BS会自己猜测编码，把不正确的编码排除掉，BS就更容易猜到正确编码。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">exclude_encodings</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;iso-8859-7&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="p">)</span>
<span class="c1"># &lt;h1&gt;םולש&lt;/h1&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span><span class="p">)</span>
<span class="c1"># WINDOWS-1255</span>
</pre></div>
</div>
<p>猜测的结果 Windows-1255 可能不是 100% 准确，但是 Windows-1255 编码是 ISO-8859-8 的扩展集，
所以猜测结果已经十分接近了，并不影响使用。(<code class="docutils literal notranslate"><span class="pre">exclude_encodings</span></code> 参数是 4.4.0版本的新功能)</p>
<p>少数情况下(通常是UTF-8编码的文档中包含了其它编码格式的文件)，想获得正确的 Unicode 编码就不得不将
文档中少数特殊编码字符替换成特殊 Unicode 编码，“REPLACEMENT CHARACTER” (U+FFFD, �) <a class="footnote-reference brackets" href="#id156" id="id106" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> 。
如果 Beautifu Soup 猜测文档编码时作了特殊字符的替换，那么 Beautiful Soup 会把 <code class="docutils literal notranslate"><span class="pre">UnicodeDammit</span></code>
或 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">.contains_replacement_characters</span></code> 属性标记为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。
这样就可以知道当前文档进行 Unicode 编码后丢失了一部分特殊内容字符。如果文档中包含 � 而
<code class="docutils literal notranslate"><span class="pre">.contains_replacement_characters</span></code> 属性是 <code class="docutils literal notranslate"><span class="pre">False</span></code> ,则表示 � 就是文档中原来的字符，
不是转码失败。</p>
<section id="id107">
<h2>输出编码<a class="headerlink" href="#id107" title="此标题的永久链接">¶</a></h2>
<p>通过 Beautiful Soup 输出文档时，不管输入文档是什么编码方式，输出编码均为UTF-8编码，
下面例子输入文档是 Latin-1 编码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1"> &lt;html&gt;</span>
<span class="s1">  &lt;head&gt;</span>
<span class="s1">   &lt;meta content=&quot;text/html; charset=ISO-Latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="s1">  &lt;/head&gt;</span>
<span class="s1">  &lt;body&gt;</span>
<span class="s1">   &lt;p&gt;Sacr</span><span class="se">\xe9</span><span class="s1"> bleu!&lt;/p&gt;</span>
<span class="s1">  &lt;/body&gt;</span>
<span class="s1"> &lt;/html&gt;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Sacré bleu!</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>注意，输出文档中的 &lt;meta&gt; 标签内容中的编码信息已经修改成了与输出编码一致的 UTF-8。</p>
<p>如果不想用 UTF-8 编码输出，可以将编码方式传入 <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;meta content=&quot;text/html; charset=latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>还可以调用 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 对象或任意节点的 <code class="docutils literal notranslate"><span class="pre">encode()</span></code> 方法，就像 Python 的字符串
调用 <code class="docutils literal notranslate"><span class="pre">encode()</span></code> 方法一样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">)</span>
<span class="c1"># b&#39;&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="c1"># b&#39;&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>如果文档中包含当前编码不支持的字符，那么这些字符将被转换成一系列 XML 特殊字符引用，下面例子中
包含了 Unicode 编码字符 SNOWMAN:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;&lt;b&gt;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&lt;/b&gt;&quot;</span>
<span class="n">snowman_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">snowman_soup</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>SNOWMAN 字符在 UTF-8 编码中可以正常显示(看上去是 ☃)，但有些编码不支持 SNOWMAN 字符，比如
ISO-Latin-1 或 ASCII，那么在这些编码中 SNOWMAN 字符会被转换成 “&amp;#9731”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;b&gt;\xe2\x98\x83&lt;/b&gt;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;b&gt;&amp;#9731;&lt;/b&gt;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">))</span>
<span class="c1"># b&#39;&lt;b&gt;&amp;#9731;&lt;/b&gt;&#39;</span>
</pre></div>
</div>
</section>
<section id="unicode-dammit">
<h2>Unicode, Dammit<a class="headerlink" href="#unicode-dammit" title="此标题的永久链接">¶</a></h2>
<p>译者备注: Unicode Dammit 是 Beautiful Soup 内置库，主要用来猜测文档编码。</p>
<p><a class="reference external" href="Unicode,Dammit">编码自动检测</a> 功能可以在 Beautiful Soup 以外使用。当遇到一段未知编码
的文档时，可以通过下面方法把它转换为 Unicode 编码</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">UnicodeDammit</span>
<span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xc2\xab</span><span class="s2">Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!</span><span class="se">\xc2\xbb</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
<span class="c1"># «Sacré bleu!»</span>
<span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="c1"># &#39;utf-8&#39;</span>
</pre></div>
</div>
<p>如果安装了 Python 的 <code class="docutils literal notranslate"><span class="pre">chardet</span></code> 或 <code class="docutils literal notranslate"><span class="pre">cchardet</span></code> 库，那么编码检测功能的准确率将大大提高。
输入的字符越多，检测结果越准确，如果事先猜测到一些可能编码，那么可以将猜测的编码作为参数，
这样将优先检测这些编码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">&quot;Sacr</span><span class="se">\xe9</span><span class="s2"> bleu!&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;latin-1&quot;</span><span class="p">,</span> <span class="s2">&quot;iso-8859-1&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
<span class="c1"># Sacré bleu!</span>
<span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="c1"># &#39;latin-1&#39;</span>
</pre></div>
</div>
<p><a class="reference external" href="Unicode,Dammit">编码自动检测</a> 功能中有 2 项功能是 Beautiful Soup 库中用不到的</p>
<section id="id110">
<h3>智能引号<a class="headerlink" href="#id110" title="此标题的永久链接">¶</a></h3>
<p>使用 Unicode 时，Beautiful Soup 还会智能的把引号 <a class="footnote-reference brackets" href="#id157" id="id111" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> 转换成 HTML 或 XML 中的特殊字符:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&lt;p&gt;I just </span><span class="se">\x93</span><span class="s2">love</span><span class="se">\x94</span><span class="s2"> Microsoft Word</span><span class="se">\x92</span><span class="s2">s smart quotes&lt;/p&gt;&quot;</span>

<span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># &#39;&lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;&#39;</span>

<span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># &#39;&lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>也可以把引号转换为 ASCII 码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># &#39;&lt;p&gt;I just &quot;love&quot; Microsoft Word\&#39;s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>虽然这个功能很有用，但是 Beautiful Soup 没有使用这种方式。默认情况下，Beautiful Soup
把引号转换成 Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># &#39;&lt;p&gt;I just “love” Microsoft Word’s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
</section>
<section id="id112">
<h3>矛盾的编码<a class="headerlink" href="#id112" title="此标题的永久链接">¶</a></h3>
<p>有时文档的大部分都是用 UTF-8，但同时还包含了 Windows-1252 编码的字符，就像微软的智能引号 <a class="footnote-reference brackets" href="#id157" id="id113" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> 一样。
一些包含多个信息的来源网站容易出现这种情况。<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法可以把这类文档转换成纯
UTF-8 编码格式，看个简单的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">snowmen</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">quote</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;</span><span class="se">\N{LEFT DOUBLE QUOTATION MARK}</span><span class="s2">I like snowmen!</span><span class="se">\N{RIGHT DOUBLE QUOTATION MARK}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">snowmen</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">quote</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;windows_1252&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这段文档很杂乱，snowmen 是 UTF-8 编码，引号是 Windows-1252 编码，直接输出时不能同时显示
snowmen 和引号，因为它们编码不同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="c1"># ☃☃☃�I like snowmen!�</span>

<span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">))</span>
<span class="c1"># â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</span>
</pre></div>
</div>
<p>如果对这段文档用 UTF-8 解码就会产生 <code class="docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code> 异常，如果用 Windows-1252
解码就会得到一堆乱码。幸好，<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法会把这段字符串转换成 UTF-8
编码，允许我们同时显示出文档中的 snowmen 和引号:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_doc</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="o">.</span><span class="n">detwingle</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">))</span>
<span class="c1"># ☃☃☃“I like snowmen!”</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法只能解码包含在 UTF-8 编码中的 Windows-1252 编码内容，
（反过来的话，大概也可以）但这是最常见的用法。</p>
<p>在创建 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 或 <code class="docutils literal notranslate"><span class="pre">UnicodeDammit</span></code> 对象前一定要先对文档调用
<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> 确保文档的编码方式正确。Beautiful Soup
会假设文档只包含一种编码，如果尝试去解析一段同时包含 UTF-8 和 Windows-1252 编码的文档，
就有可能被误判成整个文档都是 Windows-1252 编码，解析结果就会得到一堆乱码，
比如: â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”。</p>
<p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> 方法在 Beautiful Soup 4.1.0 版本中新增。</p>
</section>
</section>
</section>
<section id="id114">
<h1>行编号<a class="headerlink" href="#id114" title="此标题的永久链接">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">html.parser</span></code> 和 <code class="docutils literal notranslate"><span class="pre">html5lib</span></code> 解析器可以跟踪原始文档中发现的每个 Tag。查看原始信息可以
使用 <code class="docutils literal notranslate"><span class="pre">Tag.sourceline</span></code> （行号）和 <code class="docutils literal notranslate"><span class="pre">Tag.sourcepos</span></code> （标签所在行的起始位置）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p</span><span class="se">\n</span><span class="s2">&gt;Paragraph 1&lt;/p&gt;</span><span class="se">\n</span><span class="s2">    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">((</span><span class="n">tag</span><span class="o">.</span><span class="n">sourceline</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">sourcepos</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)))</span>
<span class="c1"># (1, 0, &#39;Paragraph 1&#39;)</span>
<span class="c1"># (3, 4, &#39;Paragraph 2&#39;)</span>
</pre></div>
</div>
<p>注意，这两个解析器的 <code class="docutils literal notranslate"><span class="pre">sourceline</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sourcepos</span></code> 会有些许的不同。html.parser 将
标签开始的 小于号作为标签起始符号，而 html5lib 将标签开始的大于号作为标签起始符号</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html5lib&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">((</span><span class="n">tag</span><span class="o">.</span><span class="n">sourceline</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">sourcepos</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)))</span>
<span class="c1"># (2, 0, &#39;Paragraph 1&#39;)</span>
<span class="c1"># (3, 6, &#39;Paragraph 2&#39;)</span>
</pre></div>
</div>
<p>可以在 BeautifulSoup 构造函数中配置 <code class="docutils literal notranslate"><span class="pre">store_line_numbers=False</span></code> 来关闭这个功能</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p</span><span class="se">\n</span><span class="s2">&gt;Paragraph 1&lt;/p&gt;</span><span class="se">\n</span><span class="s2">    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">store_line_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">sourceline</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>这个功能在 4.8.1 版本中引入，lxml 解析器不支持这个功能。</p>
</section>
<section id="id115">
<h1>比较对象是否相同<a class="headerlink" href="#id115" title="此标题的永久链接">¶</a></h1>
<p>两个 <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Tag</span></code> 对象具有相同的 HTML 或 XML 结构时，
Beautiful Soup就判断这两个对象相同。这个例子中，2个 &lt;b&gt; 标签在 BS 中是相同的，
尽管他们在文档树的不同位置，但是具有相同的表象: “&lt;b&gt;pizza&lt;/b&gt;”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">first_b</span><span class="p">,</span> <span class="n">second_b</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">first_b</span> <span class="o">==</span> <span class="n">second_b</span><span class="p">)</span>
<span class="c1"># True</span>

<span class="nb">print</span><span class="p">(</span><span class="n">first_b</span><span class="o">.</span><span class="n">previous_element</span> <span class="o">==</span> <span class="n">second_b</span><span class="o">.</span><span class="n">previous_element</span><span class="p">)</span>
<span class="c1"># False</span>
</pre></div>
</div>
<p>如果想判断两个对象是否严格的指向同一个对象可以通过 <code class="docutils literal notranslate"><span class="pre">is</span></code> 来判断</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">first_b</span> <span class="ow">is</span> <span class="n">second_b</span>
<span class="c1"># False</span>
</pre></div>
</div>
</section>
<section id="id116">
<h1>复制Beautiful Soup对象<a class="headerlink" href="#id116" title="此标题的永久链接">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">copy.copy()</span></code> 方法可以复制任意 <code class="docutils literal notranslate"><span class="pre">Tag</span></code> 或 <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> 对象</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="n">p_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p_copy</span><span class="p">)</span>
<span class="c1"># &lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;</span>
</pre></div>
</div>
<p>复制后的对象跟与对象是相等的，但指向不同的内存地址</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="n">p_copy</span>
<span class="c1"># True</span>

<span class="nb">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="n">p_copy</span>
<span class="c1"># False</span>
</pre></div>
</div>
<p>源对象和复制对象的区别是源对象在文档树中，而复制后的对象是独立的还没有添加到文档树中。
复制后对象的效果跟调用了 <code class="docutils literal notranslate"><span class="pre">extract()</span></code> 方法相同。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="n">p_copy</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>这是因为相等的对象不能同时插入相同的位置</p>
</section>
<section id="id117">
<h1>高级自定义解析<a class="headerlink" href="#id117" title="此标题的永久链接">¶</a></h1>
<p>Beautiful Soup 提供多种途径自定义解析器如果解析 HTML 和 XML。本章覆盖了最常用的自定义方法。</p>
<section id="id118">
<h2>解析部分文档<a class="headerlink" href="#id118" title="此标题的永久链接">¶</a></h2>
<p>如果仅仅因为想要查找文档中的 &lt;a&gt; 标签而将整片文档进行解析，实在是浪费内存和时间。最快的方法
是从一开始 就把 &lt;a&gt; 标签以外的东西都忽略掉。 <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> 类可以选择解析哪部分文档内容，
创建一个 <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> 对象并作为 <code class="docutils literal notranslate"><span class="pre">parse_only</span></code> 参数给 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 的构造
方法即可。</p>
<p>(注意，<em>这个功能在 html5lib 解析器中无法使用</em>。如果使用 html5lib 解析器，整篇文档都会被解析，
这是因为 html5lib 会重新排列文档树的结构，如果部分节点不在文档树中，会导致崩溃。为了避免混淆，
下面的例子中 Beautiful Soup 都强制指定使用了 Python 内置解析器。)</p>
</section>
<section id="soupstrainer">
<h2>SoupStrainer<a class="headerlink" href="#soupstrainer" title="此标题的永久链接">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> 类接受与典型搜索方法相同的参数： <a class="reference internal" href="#name">name</a> , <a class="reference internal" href="#attrs">attrs</a> ,
<a class="reference external" href="recursive">recursive</a> , <a class="reference external" href="string">string</a> , <a class="reference external" href="kwargs">**kwargs</a> 。
下面举例说明三种 <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> 对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">SoupStrainer</span>

<span class="n">only_a_tags</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

<span class="n">only_tags_with_id_link2</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_short_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>

<span class="n">only_short_strings</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_short_string</span><span class="p">)</span>
</pre></div>
</div>
<p>再拿“爱丽丝”文档来举例，来看看使用三种 <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> 对象做参数会有什么不同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_a_tags</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c1">#  Elsie</span>
<span class="c1"># &lt;/a&gt;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#  Lacie</span>
<span class="c1"># &lt;/a&gt;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span>
<span class="c1">#  Tillie</span>
<span class="c1"># &lt;/a&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_tags_with_id_link2</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#  Lacie</span>
<span class="c1"># &lt;/a&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_short_strings</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># Elsie</span>
<span class="c1"># ,</span>
<span class="c1"># Lacie</span>
<span class="c1"># and</span>
<span class="c1"># Tillie</span>
<span class="c1"># ...</span>
<span class="c1">#</span>
</pre></div>
</div>
<p>还可以将 <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> 作为参数传入 <a class="reference internal" href="#id28">搜索文档树</a> 中提到的方法。虽然不常用，但还是提一下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">only_short_strings</span><span class="p">)</span>
<span class="c1"># [&#39;\n\n&#39;, &#39;\n\n&#39;, &#39;Elsie&#39;, &#39;,\n&#39;, &#39;Lacie&#39;, &#39; and\n&#39;, &#39;Tillie&#39;,</span>
<span class="c1">#  &#39;\n\n&#39;, &#39;...&#39;, &#39;\n&#39;]</span>
</pre></div>
</div>
</section>
<section id="id122">
<h2>自定义包含多个值的属性<a class="headerlink" href="#id122" title="此标题的永久链接">¶</a></h2>
<p>在 HTML 文档中，像 <code class="docutils literal notranslate"><span class="pre">class</span></code> 这样的属性的值是一个列表，像 <code class="docutils literal notranslate"><span class="pre">id</span></code> 这样的属性的值是一个单一字符串，
因为 HTML 标准定义了这些属性的不同行为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a class=&quot;cls1 cls2&quot; id=&quot;id1 id2&quot;&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [&#39;cls1&#39;, &#39;cls2&#39;]</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># &#39;id1 id2&#39;</span>
</pre></div>
</div>
<p>设置 <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes=None</span></code> 可以禁用多值的自动识别，然后全部属性的值都变成一个字符串</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># &#39;cls1 cls2&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># &#39;id1 id2&#39;</span>
</pre></div>
</div>
<p>如果给 <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes</span></code> 参数传入一个字典，可以实现一点点解析自定义。如果需要这么做，
查看 <code class="docutils literal notranslate"><span class="pre">HTMLTreeBuilder.DEFAULT_CDATA_LIST_ATTRIBUTES</span></code> 了解 Beautiful Soup 的默认配置，
这些均是基于 HTML 标准配置的。</p>
<p><cite>(这个功能添加于 Beautiful Soup 4.8.0)</cite></p>
</section>
<section id="id123">
<h2>处理重复属性<a class="headerlink" href="#id123" title="此标题的永久链接">¶</a></h2>
<p>使用 <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> 解析器时，可以通过设置 <code class="docutils literal notranslate"><span class="pre">on_duplicate_attribute</span></code> 参数，来定义当
Beautiful Soup 在 tag 中发现重复的属性名字时如何处理</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://url1/&quot; href=&quot;http://url2/&quot;&gt;&#39;</span>
</pre></div>
</div>
<p>默认行为是，重名属性会使用最后出现的值</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;href&#39;</span><span class="p">]</span>
<span class="c1"># http://url2/</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">on_duplicate_attribute</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;href&#39;</span><span class="p">]</span>
<span class="c1"># http://url2/</span>
</pre></div>
</div>
<p>当 <code class="docutils literal notranslate"><span class="pre">on_duplicate_attribute='ignore'</span></code> 时，Beautiful Soup 会使用第一个出现的值，然后忽略
后出现的值</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">on_duplicate_attribute</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;href&#39;</span><span class="p">]</span>
<span class="c1"># http://url1/</span>
</pre></div>
</div>
<p>（lxml 和 html5lib 总是采用这种处理方式，它们的默认行为不能通过 Beautiful Soup 配置。）</p>
<p>如果需要复杂的控制，可以传入一个方法，当属性值重复时会被调用</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">attributes_so_far</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes_so_far</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">attributes_so_far</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes_so_far</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
    <span class="n">attributes_so_far</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">on_duplicate_attribute</span><span class="o">=</span><span class="n">accumulate</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;href&#39;</span><span class="p">]</span>
<span class="c1"># [&quot;http://url1/&quot;, &quot;http://url2/&quot;]</span>
</pre></div>
</div>
<p>这个特性新增于 Beautiful Soup 4.9.1。</p>
</section>
<section id="id124">
<h2>实例化自定义子类<a class="headerlink" href="#id124" title="此标题的永久链接">¶</a></h2>
<p>当解析器传递给 Beautiful Soup 一个标签或一个字符串后，Beautiful Soup 会实例化为 <cite>Tag</cite> 或
<cite>NavigableString</cite> 对象，并包含相关信息。如果想修改默认行为，可以让 Beautiful Soup 实例化
<cite>Tag</cite> 或 <cite>NavigableString</cite> 的子类，子类中可以自定义行为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">Tag</span><span class="p">,</span> <span class="n">NavigableString</span>
<span class="k">class</span> <span class="nc">MyTag</span><span class="p">(</span><span class="n">Tag</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MyString</span><span class="p">(</span><span class="n">NavigableString</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;div&gt;some text&lt;/div&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="n">MyTag</span><span class="p">)</span>
<span class="c1"># False</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">div</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">MyString</span><span class="p">)</span>
<span class="c1"># False</span>

<span class="n">my_classes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">Tag</span><span class="p">:</span> <span class="n">MyTag</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">:</span> <span class="n">MyString</span> <span class="p">}</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">element_classes</span><span class="o">=</span><span class="n">my_classes</span><span class="p">)</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="n">MyTag</span><span class="p">)</span>
<span class="c1"># True</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">div</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">MyString</span><span class="p">)</span>
<span class="c1"># True</span>
</pre></div>
</div>
<p>这种用法可用在于 Beautiful Soup 与测试框架集成。</p>
<p>这个特性新增于 Beautiful Soup 4.8.1。</p>
</section>
</section>
<section id="id125">
<h1>常见问题<a class="headerlink" href="#id125" title="此标题的永久链接">¶</a></h1>
<section id="diagnose">
<span id="id126"></span><h2>代码诊断<a class="headerlink" href="#diagnose" title="此标题的永久链接">¶</a></h2>
<p>如果想知道 Beautiful Soup 到底怎样处理一份文档，可以将文档传入 <code class="docutils literal notranslate"><span class="pre">diagnose()</span></code>
方法(Beautiful Soup 4.2.0中新增)， Beautiful Soup 会输出一份报告，
说明不同的解析器会怎样处理这段文档，并标出当前的解析过程会使用哪种解析器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4.diagnose</span> <span class="kn">import</span> <span class="n">diagnose</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;bad.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">diagnose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Diagnostic running on Beautiful Soup 4.2.0</span>
<span class="c1"># Python version 2.7.3 (default, Aug  1 2012, 05:16:07)</span>
<span class="c1"># I noticed that html5lib is not installed. Installing it may help.</span>
<span class="c1"># Found lxml version 2.3.2.0</span>
<span class="c1">#</span>
<span class="c1"># Trying to parse your data with html.parser</span>
<span class="c1"># Here&#39;s what html.parser did with the document:</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">diagnose()</span></code> 方法的输出结果可能帮助你找到问题的原因，如果不行，还可以把结果复制出来以
便寻求他人的帮助。</p>
</section>
<section id="id127">
<h2>文档解析错误<a class="headerlink" href="#id127" title="此标题的永久链接">¶</a></h2>
<p>文档解析错误有两种。一种是崩溃，Beautiful Soup 尝试解析一段文档结果却抛除了异常，通常是
<code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError</span></code> 。还有一种异常情况，是Beautiful Soup 解析后的文档树
看起来与原来的内容相差很多。</p>
<p>这些错误几乎都不是 Beautiful Soup 的原因，这不是因为 Beautiful Soup 的代码写得多优秀，
而是因为 Beautiful Soup 没有包含任何文档解析代码。异常产生自被依赖的解析器，如果解析器不能
很好的解析出当前的文档，那么最好的办法是换一个解析器。更多细节查看 <a class="reference internal" href="#id10">安装解析器</a> 章节。</p>
<p>最常见的解析错误是 <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError:</span> <span class="pre">malformed</span> <span class="pre">start</span> <span class="pre">tag</span></code> 和
<code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError:</span> <span class="pre">bad</span> <span class="pre">end</span> <span class="pre">tag</span></code> 。这都是由Python内置的解析器引起的，
解决方法是 <a class="reference external" href="安装解析器">安装 lxml 或 html5lib</a> 。</p>
<p>最常见的非预期行为是发现不了一个确定存在稳当中的 Tag。光是用眼睛就能轻易发现，但用 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>
方法返回 [] ，用 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法返回 None 。这是 Python 内置解析器的又一个问题: 解析器会跳过那些
它不知道的 tag。解决方法还是 <a class="reference external" href="安装解析器">安装 lxml 或 html5lib</a></p>
</section>
<section id="id129">
<h2>版本错误<a class="headerlink" href="#id129" title="此标题的永久链接">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SyntaxError:</span> <span class="pre">Invalid</span> <span class="pre">syntax</span></code> (异常位置在代码行: <code class="docutils literal notranslate"><span class="pre">ROOT_TAG_NAME</span> <span class="pre">=</span> <span class="pre">u'[document]'</span></code> )，
原因是用 Python2 版本的 Beautiful Soup 未经过代码转换，直接在 Python3 中运行。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">HTMLParser</span></code> 因为在 Python3 中执行 Python2 版本的 Beautiful Soup。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">html.parser</span></code> 因为在 Python2 中执行 Python3 版本的 Beautiful Soup</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">BeautifulSoup</span></code> 因为在没有安装 Beautiful Soup3 库的 Python 环境下执行代码，
或忘记了 Beautiful Soup4 的代码需要从 <code class="docutils literal notranslate"><span class="pre">bs4</span></code> 包中引入。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">bs4</span></code> 因为当前 Python 环境下还没有安装 Beautiful Soup4。</p></li>
</ul>
</section>
<section id="id130">
<h2>解析成XML<a class="headerlink" href="#id130" title="此标题的永久链接">¶</a></h2>
<p>默认情况下，Beautiful Soup 会将当前文档作为 HTML 格式解析，如果要解析 XML 文档，要在
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 构造方法中加入第二个参数 “xml”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>当然，还需要 <a class="reference external" href="安装解析器">安装 lxml</a></p>
</section>
<section id="id131">
<h2>其它解析器的错误<a class="headerlink" href="#id131" title="此标题的永久链接">¶</a></h2>
<ul class="simple">
<li><p>如果同样的代码在不同环境下结果不同，可能是因为两个环境下使用不同的解析器造成的。
例如这个环境中安装了 lxml，而另一个环境中只有 html5lib, <a class="reference internal" href="#id101">解析器之间的区别</a> 中说明了原因。
修复方法是在 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 的构造方法中中指定解析器。</p></li>
<li><p>因为HTML标签是 <a class="reference external" href="http://www.w3.org/TR/html5/syntax.html#syntax">大小写敏感</a> 的，
所以解析器会将 tag 和属性都转换成小写。例如文档中的 &lt;TAG&gt;&lt;/TAG&gt; 会被转换为 &lt;tag&gt;&lt;/tag&gt; 。
如果想要保留 tag 的大写的话，那么应该将文档 <a class="reference internal" href="#id130">解析成XML</a> 。</p></li>
</ul>
</section>
<section id="id133">
<h2>杂项错误<a class="headerlink" href="#id133" title="此标题的永久链接">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'charmap'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span>
<span class="pre">'\xfoo'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">bar</span></code> (或其它类型的 <code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code> )的错误，
主要是两方面的原因，第一种是正在使用的终端(console)无法显示部分Unicode，参考
<a class="reference external" href="http://wiki.Python.org/moin/PrintFails">Python wiki</a> ，第二种是向文件
写入时，被写入文件不支持部分 Unicode，这时需要用 <code class="docutils literal notranslate"><span class="pre">u.encode(&quot;utf8&quot;)</span></code> 方法将
编码转换为UTF-8。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">[attr]</span></code> 因为调用 <code class="docutils literal notranslate"><span class="pre">tag['attr']</span></code> 方法而引起，因为这个 tag 没有定义
该属性。出错最多的是 <code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">'href'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">'class'</span></code> 。如果不确定
某个属性是否存在时，用 <code class="docutils literal notranslate"><span class="pre">tag.get('attr')</span></code> 方法去获取它，跟获取 Python 字典的 key 一样。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'ResultSet'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> 错误通常是
因为把 <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> 的返回结果当作一个 tag 或文本节点使用，实际上返回结果是一个
列表或 <code class="docutils literal notranslate"><span class="pre">ResultSet</span></code> 对象的字符串，需要对结果进行循环才能得到每个节点的 <code class="docutils literal notranslate"><span class="pre">.foo</span></code>
属性。 或者使用 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法仅获取到一个节点。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'NoneType'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> 这个错误通常是
在调用了 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法后直节点取某个属性 foo。但是 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 方法并没有找到任何
结果，所以它的返回值是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。需要找出为什么 <code class="docutils literal notranslate"><span class="pre">find()</span></code> 的返回值是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'NavigableString'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> 这种问题
通常是因为吧一个字符串当做一个 tag 来处理。可能在迭代一个列表时，期望其中都是 tag，但实际上
列表里既包含 tag 也包含字符串。</p></li>
</ul>
</section>
<section id="id134">
<h2>如何提高效率<a class="headerlink" href="#id134" title="此标题的永久链接">¶</a></h2>
<p>Beautiful Soup对文档的解析速度不会比它所依赖的解析器更快，如果对计算时间要求很高或者
计算机的时间比程序员的时间更值钱，那么就应该直接使用 <a class="reference external" href="http://lxml.de/">lxml</a> 。</p>
<p>换句话说，还有提高 Beautiful Soup 效率的办法，使用lxml作为解析器。Beautiful Soup
用 lxml 做解析器比用 html5lib 或 Python 内置解析器速度快很多。</p>
<p>安装 <a class="reference external" href="http://pypi.Python.org/pypi/cchardet/">cchardet</a> 后文档的解码的编码检测
速度会更快。</p>
<p><a class="reference internal" href="#id118">解析部分文档</a> 不会节省多少解析时间，但是会节省很多内存，并且搜索时也会变得更快。</p>
</section>
</section>
<section id="id136">
<h1>翻译这篇文档<a class="headerlink" href="#id136" title="此标题的永久链接">¶</a></h1>
<p>非常感谢欢迎翻译 Beautiful Soup 的文档。翻译内容应当基于 MIT 协议，就像 Beautiful Soup 和
英文文档一样。</p>
<p>有两种方式将翻译内容添加到 Beautiful Soup 的网站上：</p>
<ol class="arabic simple">
<li><p>在 Beautiful Soup 代码库上创建一个分支，添加翻译，然后合并到主分支。就像修改源代码一样。</p></li>
<li><p>向 Beautiful Soup 讨论组里发送一个消息，带上翻译的链接，或翻译内容的附件。</p></li>
</ol>
<p>使用中文或葡萄牙语的翻译作为模型。尤其注意，请翻译源文件 <code class="docutils literal notranslate"><span class="pre">doc/source/index.rst</span></code>，
而不是 HTML 版本的文档。这样才能将文档发布为多种格式，而不局限于 HTML。</p>
</section>
<section id="beautiful-soup-3">
<h1>Beautiful Soup 3<a class="headerlink" href="#beautiful-soup-3" title="此标题的永久链接">¶</a></h1>
<p>Beautiful Soup 3 是上一个发布版本，目前已经停止维护。Beautiful Soup 3 库目前已经被
几个主要的 linux 发行版添加到源里:</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">Python-beautifulsoup</span></code></p>
<p>在 PyPi 中分发的包名字是 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> :</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">easy_install</span> <span class="pre">BeautifulSoup</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">BeautifulSoup</span></code></p>
<p>或通过 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/download/3.x/BeautifulSoup-3.2.0.tar.gz">Beautiful Soup 3.2.0源码包</a> 安装。</p>
<p>如果是通过 <code class="docutils literal notranslate"><span class="pre">easy_install</span> <span class="pre">beautifulsoup</span></code> 或 <code class="docutils literal notranslate"><span class="pre">easy_install</span>
<span class="pre">BeautifulSoup</span></code> 安装，然后代码无法运行，那么可能是安装了错误的 Beautiful Soup 3 版本。
应该这样安装 <code class="docutils literal notranslate"><span class="pre">easy_install</span> <span class="pre">beautifulsoup4</span></code>。</p>
<p>Beautiful Soup 3 的在线文档查看 <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">这里</a> .</p>
<section id="id138">
<h2>迁移到 BS4<a class="headerlink" href="#id138" title="此标题的永久链接">¶</a></h2>
<p>大部分使用 Beautiful Soup 3 编写的代码都可以在 Beautiful Soup 4 上运行，
只有一个小变动。只要把引用包的名字从 <a class="reference internal" href="#bs4.BeautifulSoup" title="bs4.BeautifulSoup"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a> 改为 <code class="docutils literal notranslate"><span class="pre">bs4</span></code>，比如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">BeautifulSoup</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
</pre></div>
</div>
<p>修改为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
</pre></div>
</div>
<ul class="simple">
<li><p>如果代码抛出 <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> 异常 “No module named BeautifulSoup”，
原因可能是尝试执行 Beautiful Soup 3，但环境中只安装了 Beautiful Soup 4。</p></li>
<li><p>如果代码抛出 <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> 异常 “No module named bs4”，原因可能是尝试
运行 Beautiful Soup 4 的代码，但环境中只安装了Beautiful Soup 3。</p></li>
</ul>
<p>尽管 BS4 兼容绝大部分 BS3 的功能，但 BS3 中的大部分方法已经不推荐使用了，旧方法标记废弃，
并按照 <a class="reference external" href="http://www.Python.org/dev/peps/pep-0008/">PEP8标准</a> 重新命名了新方法。
虽然有大量的重命名和修改，但只有少数几个方法没有向下兼容。</p>
<p>下面内容就是 BS3 迁移到 BS4 的注意事项:</p>
<section id="id139">
<h3>解析器的变化<a class="headerlink" href="#id139" title="此标题的永久链接">¶</a></h3>
<p>Beautiful Soup 3 曾使用 Python 的 <code class="docutils literal notranslate"><span class="pre">SGMLParser</span></code> 解析器，这个模块在 Python3
中已经被移除了。Beautiful Soup 4 默认使用系统的 <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> , 也可以使用
lxml 或 html5lib 扩展库代替。查看 <a class="reference internal" href="#id10">安装解析器</a> 章节。</p>
<p>因为解析器 <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> 与 <code class="docutils literal notranslate"><span class="pre">SGMLParser</span></code> 不同。BS4 和 BS3 处理相同的文档会
产生不同的对象结构。使用 lxml 或 html5lib 解析文档的时候，如果添加了 <code class="docutils literal notranslate"><span class="pre">html.parser</span></code>
参数，解析的对象又会发生变化。如果发生了这种情况，只能修改对应的文档处理代码了。</p>
</section>
<section id="id140">
<h3>方法名的变化<a class="headerlink" href="#id140" title="此标题的永久链接">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">renderContents</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">encode_contents</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">replaceWith</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">replace_with</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">replaceWithChildren</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">unwrap</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findAll</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findAllNext</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all_next</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findAllPrevious</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all_previous</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findNext</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findNextSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next_sibling</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findNextSiblings</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findParent</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_parent</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findParents</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_parents</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findPrevious</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findPreviousSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous_sibling</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findPreviousSiblings</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nextSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_sibling</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">previousSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_sibling</span></code></p></li>
</ul>
<p>Beautiful Soup 构造方法的参数部分也有名字变化:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(parseOnlyThese=...)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BeautifulSoup(parse_only=...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(fromEncoding=...)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BeautifulSoup(from_encoding=...)</span></code></p></li>
</ul>
<p>为了适配 Python3，修改了一个方法名:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.has_key()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.has_attr()</span></code></p></li>
</ul>
<p>修改了一个属性名，让它看起来更专业点:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.isSelfClosing</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.is_empty_element</span></code></p></li>
</ul>
<p>修改了下面 3 个属性的名字，以免与 Python 保留字冲突。这些变动不是向下兼容的，如果在 BS3
中使用了这些属性，那么在 BS4 中这些代码无法执行。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.Unicode</span> <span class="pre">-&gt;</span> <span class="pre">UnicodeDammit.Unicode_markup</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.next</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.next_element</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tag.previous</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.previous_element</span></code></p></li>
</ul>
</section>
<section id="id141">
<h3>生成器<a class="headerlink" href="#id141" title="此标题的永久链接">¶</a></h3>
<p>将下列生成器按照 PEP8 标准重新命名，并转换成对象的属性:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">childGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">children</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nextGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_elements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nextSiblingGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">previousGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_elements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">previousSiblingGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_siblings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">recursiveChildGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">descendants</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parentGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">parents</span></code></p></li>
</ul>
<p>所以要把这样的代码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parentGenerator</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>替换为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>(其实老方法也可以继续使用)</p>
<p>有的生成器循环结束后会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 然后结束。这是个 bug。新版生成器不再返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>BS4 中增加了 2 个新的生成器， <a class="reference internal" href="#strings-stripped-strings">.strings 和 stripped_strings</a> 。 <code class="docutils literal notranslate"><span class="pre">.strings</span></code> 生成器
返回 NavigableString 对象， <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code> 方法返回去除前后空白的 Python 的
string 对象。</p>
</section>
<section id="id142">
<h3>XML<a class="headerlink" href="#id142" title="此标题的永久链接">¶</a></h3>
<p>BS4 中移除了解析 XML 的 <code class="docutils literal notranslate"><span class="pre">BeautifulStoneSoup</span></code> 类。如果要解析一段 XML 文档，使用
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 构造方法并在第二个参数设置为“xml”。同时 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 构造
方法也不再识别 <code class="docutils literal notranslate"><span class="pre">isHTML</span></code> 参数。</p>
<p>Beautiful Soup 处理 XML 空标签的方法升级了。旧版本中解析 XML 时必须指明哪个标签是空标签。
构造方法的 <code class="docutils literal notranslate"><span class="pre">selfClosingTags</span></code> 参数已经不再使用。新版 Beautiful Soup 将所有空标签解析
为空元素，如果向空元素中添加子节点，那么这个元素就不再是空元素了。</p>
</section>
<section id="id143">
<h3>实体<a class="headerlink" href="#id143" title="此标题的永久链接">¶</a></h3>
<p>输入的 HTML 或 XML 实体都会被解析成 Unicode 字符。Beautiful Soup 3 版本中有很多相似处理
实体的方法，在新版中都被移除了。 <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 构造方法也不再接受 <code class="docutils literal notranslate"><span class="pre">smartQuotesTo</span></code>
或 <code class="docutils literal notranslate"><span class="pre">convertEntities</span></code> 参数。 <a class="reference external" href="Unicode,Dammit">编码自动检测</a> 方法依然有 <code class="docutils literal notranslate"><span class="pre">smart_quotes_to</span></code>
参数，但是默认会将引号转换成 Unicode。内容配置项 <code class="docutils literal notranslate"><span class="pre">HTML_ENTITIES</span></code> , <code class="docutils literal notranslate"><span class="pre">XML_ENTITIES</span></code> 和
<code class="docutils literal notranslate"><span class="pre">XHTML_ENTITIES</span></code> 在新版中被移除。因为它们代表的特性（转换部分而不是全部实体到 Unicode 字符）
已经不再支持。</p>
<p>如果在输出文档时想把 Unicode 字符转回 HTML 实体，而不是输出成 UTF-8 编码，那就需要用到
<a class="reference internal" href="#id98">输出格式</a> 的方法。</p>
</section>
<section id="id145">
<h3>迁移杂项<a class="headerlink" href="#id145" title="此标题的永久链接">¶</a></h3>
<p><a class="reference external" href="string">Tag.string</a> 属性现在是一个递归操作。如果 A 标签只包含了一个 B 标签，那么 A 标签的。
string 属性值与 B 标签的 string 属性值相同。</p>
<p><a class="reference internal" href="#id13">多值属性</a> 比如 <code class="docutils literal notranslate"><span class="pre">class</span></code> 属性包含一个他们的值的列表，而不是一个字符串。这可能会影响到如何按照
CSS 类名哦搜索 tag。</p>
<p>Tag 对象实现了一个 <code class="docutils literal notranslate"><span class="pre">__hash__</span></code> 方法，这样当两个 Tag 对象生成相同的摘要时会被认为相等。这可能会
改变你的脚本行为，如果你吧 Tag 对象放到字典或集合中。</p>
<p>如果使用 <code class="docutils literal notranslate"><span class="pre">find*</span></code> 方法时同时传入了 <a class="reference internal" href="#id44">string 参数</a> 和一个指定 tag 的参数比如 <a class="reference internal" href="#id42">name 参数</a> 。
Beautiful Soup 会搜索符合指定参数的 tag，并且这个 tag 的 <a class="reference external" href="string">Tag.string</a> 属性包含
<a class="reference internal" href="#id44">string 参数</a> 参数的内容。结果中 <cite>不会</cite> 包含字符串本身。旧版本中 Beautiful Soup 会忽略掉指定
tag 的参数，只搜索符合 string 的内容。</p>
<p><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> 构造方法不再支持 markupMassage 参数。现在由解析器负责文档的解析正确性。</p>
<p>很少被用到的几个解析器方法在新版中被移除，比如 <code class="docutils literal notranslate"><span class="pre">ICantBelieveItsBeautifulSoup</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BeautifulSOAP</span></code> 。
现在由解析器完全负责如何解释模糊不清的文档标记。</p>
<p><code class="docutils literal notranslate"><span class="pre">prettify()</span></code> 方法在新版中返回 Unicode 字符串，不再返回字节串。</p>
</section>
</section>
</section>
<section id="id147">
<h1>附录<a class="headerlink" href="#id147" title="此标题的永久链接">¶</a></h1>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id148" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>BeautifulSoup 的 google 讨论组不是很活跃，可能是因为库已经比较完善了吧，但是作者还是会很热心的尽量帮你解决问题的。</p>
</aside>
<aside class="footnote brackets" id="id149" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id21">1</a>,<a role="doc-backlink" href="#id27">2</a>)</span>
<p>文档被解析成树形结构，所以下一步解析过程应该是当前节点的子节点</p>
</aside>
<aside class="footnote brackets" id="id150" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">3</a><span class="fn-bracket">]</span></span>
<p>过滤器只能作为搜索文档的参数，或者说应该叫参数类型更为贴切，原文中用了 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 因此翻译为过滤器</p>
</aside>
<aside class="footnote brackets" id="id151" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id40">4</a><span class="fn-bracket">]</span></span>
<p>元素参数，HTML 文档中的一个 tag 节点，不能是文本节点</p>
</aside>
<aside class="footnote brackets" id="id152" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id19">1</a>,<a role="doc-backlink" href="#id61">2</a>,<a role="doc-backlink" href="#id68">3</a>,<a role="doc-backlink" href="#id75">4</a>,<a role="doc-backlink" href="#id82">5</a>)</span>
<p>采用先序遍历方式</p>
</aside>
<aside class="footnote brackets" id="id153" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id85">6</a><span class="fn-bracket">]</span></span>
<p>CSS选择器是一种单独的文档搜索语法，参考 <a class="reference external" href="http://www.w3school.com.cn/css/css_selector_type.asp">http://www.w3school.com.cn/css/css_selector_type.asp</a></p>
</aside>
<aside class="footnote brackets" id="id154" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id102">7</a><span class="fn-bracket">]</span></span>
<p>原文写的是 html5lib, 译者觉得这是原文档的一个笔误</p>
</aside>
<aside class="footnote brackets" id="id155" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id94">8</a><span class="fn-bracket">]</span></span>
<p>wrap含有包装，打包的意思，但是这里的包装不是在外部包装而是将当前tag的内部内容包装在一个tag里。
包装原来内容的新tag依然在执行 <a class="reference internal" href="#wrap">wrap()</a> 方法的tag内</p>
</aside>
<aside class="footnote brackets" id="id156" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id106">9</a><span class="fn-bracket">]</span></span>
<p>文档中特殊编码字符被替换成特殊字符(通常是�)的过程是Beautful Soup自动实现的，
如果想要多种编码格式的文档被完全转换正确，那么，只好，预先手动处理，统一编码格式</p>
</aside>
<aside class="footnote brackets" id="id157" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id111">1</a>,<a role="doc-backlink" href="#id113">2</a>)</span>
<p>智能引号，常出现在 microsoft 的 word 软件中，即在某一段落中按引号出现的顺序每个引号都被自动转换为左引号，或右引号。</p>
</aside>
</aside>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Deron.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>